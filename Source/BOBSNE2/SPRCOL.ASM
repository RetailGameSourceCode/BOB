** lock missile in on target*missilelock:	lda	bosstarget	beq	@notarget	sta	PICanim,x	rts@notarget:	ldy	#2	lda	(tasktable),y	sta	tmp	iny	lda	(tasktable),y	sta	temp+3	ldy	tmp		lda	#<sizetable	sta	temp	lda	#>sizetable	sta	temp+1			; Location of table of sizes!		@lockloop:	lda	TSKflags,y	; Active?	bpl	@inactive	lda	PICtype,y	;our type	cmp	#type_enemy	bne	@inactive		lda	PICxhi,y	;on screen	ora	PICyhi,y	bne	@inactive		lda	PIClocked,y		;if someone is locked on..	beq	@tryit			;this missile can lock on if;	bra	@inactive	asl	a				;it won't be blown up	cmp	PIChealth,y	bcs	@inactive@tryit:		lda	PICdirv,x	beq	@straight		lda	PICylo,x		;straight up....	cmp	PICylo,y	bcc	@inactive	bra	@setlock@straight:	lda	PICdir,x		;left and right	bmi	@seeleft@seeright:	lda	PICxlo,x	cmp	PICxlo,y	bcs	@inactive	bra	@setlock@seeleft:	lda	PICxlo,y	cmp	PICxlo,x	bcs	@inactive	@setlock:	tya	sta	PICanim,x	lda	PIClocked,y	inc	a	sta	PIClocked,y	rts	@inactive:	iny				; Next task	dec	temp+3		; Are we done yet?	bne	@lockloop	; Loop until done.	rts	** see if bob is touching any bad sprites*spritedrain:	lda	cputime	and	#1	bne @checksprites@noway:	rts@checksprites:	ldy	#2	lda	(tasktable),y	; Start task # to check against!	sta	tmp	iny	lda	(tasktable),y	; # of tasks to check	sta	temp+3			; Save count	ldy	tmp	lda	#<sizetable	sta	temp	lda	#>sizetable	sta	temp+1			; Location of table of sizes!	lda	PICsize,x	    sta tmp+4    asl a    clc    adc tmp+4    sta tmp+4           ;size of bob	stz	temp+4			;dummy var	** main grooc loop*@groocloop:	lda	TSKflags,y	; Active?	bpl	@inactive@chloop:	jsr	GROOC		; Check it!	bcc	@inactive		jsr	processcollision@inactive:	iny				; Next task	dec	temp+3		; Are we done yet?	bne	@groocloop		; Loop until done.	clc	rts	** ok...sprite is touching bob...now what*processcollision:	lda	PICtype,y	;only get enemy guys	cmp	#type_enemy	bne	@nodrain	** enemy's drain strength*	lda	enemyblind	bne	@nohurt	lda	#1	sta	PICcollide,y	jsr	makebobflash2	lda	#1					;take away strength	jsr	justdrainstrength@nohurt:	rts** signal bullet touch*@nodrain:	cmp	#type_badbullet	bne	@trywall	lda	enemyblind	bne	@noway	lda	status				;bug fix	cmp	#sleeping	beq	@noway	jsr	makebobflash2	lda	#1	sta	PIChit,y	@noway:	rts	** bob hit wall..process*@trywall:	cmp	#type_wall	beq	@hitawall	rts@hitawall:	lda	PICcount,y	cmp	#2	bcc	@notcrushed	lda	PICdirv,y		;if wall going up...ignore	bne	@notcrushed			lda	PICylo,y	sec	sbc	#30	cmp	bobypos	bcs	@notcrushed	clc	adc	#60	cmp	bobypos	bcc	@notcrushed	;	cmp	#70;	bcc	@notcrushed;	cmp	#160;	bcs	@notcrushed	lda	PICxlo,y	sec	sbc	#16+10	cmp	bobxpos	bcs	@notcrushed	clc	adc	#32+20	cmp	bobxpos	bcc	@notcrushed		stz	strength		lda	status	cmp	#walking	beq	@squish	cmp	#stopping	beq	@squish	cmp	#crouching	beq	@squish		lda	#3				;if not walking...blow up	sta	deathtype	lda	#dying	sta	status	jsr	clearscroll2	jsr	removeweapontasks		rts@squish:	lda	#1				;else just squish	sta	squished	rts** then bounce...*@notcrushed:	lda	bobxmove	bmi	@goingleft		lda	bobxpos		;if past centre of door...ignore	cmp	PICxlo,y	bcs	@nohit		lda	#1	sta	bobmr	stz	bobxmove		bra	@makesplat@nohit:	rts@goingleft:	lda	bobxpos		;if past door...ignore	cmp	PICxlo,y	bcc	@nohit2	beq	@nohit2	stz	bobxmove	lda	#1	sta	bobml@makesplat:	lda	status	cmp	#walking	bne	@nohit2	lda	accelcount	;while full out	cmp	#MAXACCEL	bne	@nohit2	jsr	setsplat@nohit2:	rts	** flaming check*weaponpicsizex:	dc.b	0,2,2,11,12,12,13,14weaponpicsizey:	dc.b	0,1,1,23,35,35,22,42	checkflame:	lda	TSKclock	and	#3	cmp	#3	bne	@nohit	lda	PICcount,x	tay	lda	PICdirv,x	bne	@str	lda	weaponpicsizex,y	bra	@setsize@str:	lda	weaponpicsizey,y@setsize:	sta	PICsize,x				lda	#1					;scan enemies...	jsr	checkhit	bcc	@nohit	lda	PICtype,y	;only get enemy guys	cmp	#type_enemy	bne	@nohit	lda	PIChealth,y	beq	@nohit	dec	a	beq	@over	dec	a@over:	sta	PIChealth,y	lda	#hitbyflame	sta	PIChit,y@nohit:	rts	** fist check*checkfist:	lda	punchflag			;only check punch when fully extended	cmp	#3	bne	@notreaching			lda	onepunch			;one hit per punch	bne	@notreaching				lda	PICxlo,x	sta	tmp+6	lda	PICylo,x	sta	tmp+7		lda	walkdir	bmi	@punchleft	lda	bobxpos	clc		adc #32				;get centre of fist	bra	@setx@punchleft:	lda	bobxpos	sec		sbc	#32@setx:	sta	PICxlo,x		lda	bobypos	clc	adc	boboffsety	sta	PICylo,x		lda	#0				;8x8 box	sta	PICsize,x	lda	#1				;look for enemy sprites	jsr	checkhit	bcc	@missed** process hit*	lda	PICtype,y	;only get enemy guys	beq	@missed	lda	PIChealth,y	beq	@missed		lda	#hitbypunch	sta	PIChit,y		lda	walkdir		;save punched dir	sta	PICvomit,y		lda	PIChealth,y	dec	a	beq	@set	dec	a@set:	sta	PIChealth,y	inc	onepunch** restore position*@missed:;	stz	PICxhi,x;	stz	PICyhi,x	lda	tmp+6		;restore position	sta	PICxlo,x	sta bobxpos	lda	tmp+7	sta	PICylo,x	sta	bobypos@notreaching:	rts** X=Task #* A=which task type to check against* If temp+4 =1 then hit on x axis*checkhit2:	asl	a	tay	lda	(tasktable),y	; Start task # to check against!	sta	tmp	iny	lda	(tasktable),y	; # of tasks to check	ldy	tmp	sta	temp+3			; Save count	lda	#<sizetable	sta	temp	lda	#>sizetable	sta	temp+1			; Location of table of sizes!	lda	PICsize,x	    sta     tmp+4    asl     a    clc    adc     tmp+4    sta     tmp+4           ;size of bullet	stz	temp+4** main loop...*@chloop:	lda	TSKflags,y	; Active@	bpl	@inactive	lda	PICtype,y	;bug fix	beq	@inactive	cmp	#type_badbullet	beq	@inactive	sty	tmp+5		; Checking for collisions against ourself@	cpx	tmp+5	beq	@inactive	jsr	GROOC		; Check it!	bcc	@inactive		sec	rts@inactive:	iny				; Next task	dec	temp+3		; Are we done yet@	bne	@chloop		; Loop until done.	clc	rtscheckhit:	asl	a	tay	lda	(tasktable),y	; Start task # to check against!	sta	tmp	iny	lda	(tasktable),y	; # of tasks to check	ldy	tmp	sta	temp+3			; Save count	lda	#<sizetable	sta	temp	lda	#>sizetable	sta	temp+1			; Location of table of sizes!	lda	PICsize,x	    sta     tmp+4    asl     a    clc    adc     tmp+4    sta     tmp+4           ;size of bullet	stz	temp+4** main loop...*@chloop:	lda	TSKflags,y	; Active@	bpl	@inactive	lda	PICtype,y	;bug fix	beq	@inactive	sty	tmp+5		; Checking for collisions against ourself@	cpx	tmp+5	beq	@inactive	jsr	GROOC		; Check it!	bcc	@inactive		sec	rts@inactive:	iny				; Next task	dec	temp+3		; Are we done yet@	bne	@chloop		; Loop until done.	clc	rts	** X=TASK1* Y=TASK2*GROOC:	lda	PICsize,y    sta tmp+5    asl a    clc    adc tmp+5    sta tmp+5           ; Pic size indexes	lda	PICxhi,x	sta	tmp+1	lda	PICxhi,y	sta	temp1+1	cmp	tmp+1		; Are X hi values the same?	beq	@fastgrooc	lda	PICxlo,x	sta	tmp	lda	PICxlo,y	sta	temp1		; Load in low values	SET16	lda	temp1	sec	sbc	tmp		; x1-x	bcs	@voka	eor	#-1	clc	adc	#1@voka:	SET8	clc			; Just fuck it and return!    rts	bra	@vok		; 8 bit from now on@fastgrooc:	lda	PICxlo,y	sec	sbc	PICxlo,x	; x1-x	bcs	@vok	eor	#-1	clc	adc	#1		; ABS(x1-x)@vok:	sta	tmp+2	sty	temp+2	ldy	tmp+4	lda	(temp),y	; X size	ldy	tmp+5	clc	adc	(temp),y	; X size	ldy	temp+2	cmp	tmp+2	bcs	@hitx	clc	rts@hitx:	lda	#1	sta	temp+4; Y section so reset local variablesresetv:	lda	PICyhi,x	sta	tmp+1	lda	PICyhi,y	sta	temp1+1	cmp	tmp+1		; Are X hi values the same@	beq	@fastgrooc	lda	PICylo,x	sta	tmp	lda	PICylo,y	sta	temp1		; Load in low values	SET16	lda	temp1	sec	sbc	tmp		; x1-x	bcs	@voka	eor	#-1	clc	adc	#1@voka:	SET8	clc			; Fuck off with off screen collisions	rts	bra	@vok		; 8 bit from now on@fastgrooc:	lda	PICylo,y        sty     temp+2        ldy     tmp+5        iny        iny        clc        adc     (temp),y        pha        lda     PICylo,x        ldy     tmp+4        iny        iny        clc        adc     (temp),y        sta     tmp+2        pla        sec        sbc     tmp+2        ; x1-x	bcs	@vok	eor	#-1	clc	adc	#1		; ABS(x1-x)@vok:	sta	tmp+2;        sty     temp+2	ldy	tmp+4	iny	lda	(temp),y	; X size	ldy	tmp+5	iny	clc	adc	(temp),y	; X size (XS+XS1)	ldy	temp+2	cmp	tmp+2	bcc	@nothitx	sec			; If we did then we hit!!!!!	rts@nothitx:	clc	rts			; Not hit so return no hit!** list of possible sizes for ultra-force sprites*sizetable:        dc.b    8,8,0			;0        dc.b    8,16,0        dc.b    16,8,0        dc.b    16,16,0        dc.b    4,4,0        dc.b    12,30,0           ;5 bob size        dc.b    12,24,0           ;borg size        dc.b    12,16,0           ;scrunched borg        dc.b    16,8,0				        dc.b    16,4,0        dc.b    16,24,0           ;10  egg        dc.b    24,8,0        dc.b    32,8,0        dc.b    40,8,0        dc.b    48,8,0        dc.b    56,8,0			;15        dc.b    16,32,0		dc.b	12,24,0			;17		dc.b	12,16,8			dc.b	12,14,10		;19		16,12,10	;crouch fudge!!!!		dc.b	12,12,12			;20		18,8,16		dc.b	19,14,0		    ;scooter - gear down		dc.b	8,40,0			;22		dc.b	8,24,0			;23 - space laser		dc.b	24,24,0			;		dc.b	16,8,-32		;25 vertical crush wall 0		dc.b	16,12,-24		;		dc.b	16,16,-16		dc.b	16,20,-8		dc.b	16,24,0		dc.b	16,32,8			;30		dc.b	16,40,16		dc.b	16,48,24		;crush wall 7		dc.b	20,40,0			;33 sonic boom 		dc.b	32,8,0			;34	gas jet, nerve zap hor.		dc.b	8,32,0			;35	gas jet, nerve zap ver.		dc.b	32,24,0			;36	venus flytrap		dc.b	20,20,0			;37	ancient boss		dc.b	4,32,0			;38 hoverzapper flame vertical		dc.b	32,4,0			;39 four way flamer horiz.		dc.b	19,13,3			;40 scorpion with tail up		dc.b	21,9,12			;41 open egg		dc.b	16,8,0			;42 hidden gun		dc.b	4,48,0			;43 death boss vomit		dc.b	16,10,0			;44 sand crab no attack		dc.b	40,12,0			;45 sand crab attacks				dc.b	15,16,-19		;46 lifter hand frame 1		dc.b	15,16,-16		;47 lifter hand frame 2		dc.b	15,16,-8		;48 lifter hand frame 3		dc.b	15,16,0			;49 lifter hand frame 4		dc.b	15,16,16		;50 lifter hand frame 5		dc.b	15,16,32		;51 lifter hand frame 6		dc.b	15,16,52		;52 lifter hand frame 7		dc.b	32,28,-16		;53 lifter head				dc.b	16,12,0			;54 cluster size 3		dc.b	16,8,0			;55 cluster size 2				dc.b	20,34,0			;56 mutoid men		dc.b	32,48,0			;57 virus boss		dc.b	16,8,0			;58 virus boss punch arm***	UNIVERSAL ROUTINE TO DETERMINE BLOCK AND BG CHAR VALUES UNDER A*	TASK.*bgcoll_long:	phb;	pha;	lda	#0;	pha;	plb;	pla	jsr bgcoll	plb	rtl	findwall_long:	jsr	findwall	rtl	findfloor_long:	jsr	findfloor	rtl	* ACC HOLDS XOFFSET (+- 128) AND A Y OFFSET (+-128) FROM TASK X,Ycollide:	sta temp+2		;xoffset	sty temp+3		;yoffset	phb	lda PICxlo,x	pha	lda PICylo,x	pha	lda PICxhi,x	pha	lda PICyhi,x	pha						;save off x,y to restore later	lda blockcounth	jsl PICxadd	lda temp+2	jsl PICxadd	lda PICxlo,x			;get h screen offset in blocks	lsr a	lsr a	lsr a	lsr a	lsr a	sta temp+4				;block x offset     lda temp+3	jsl PICyadd	;;	lda	PICylo,x;;	sta face		lda blockcountv	jsl PICyadd		lda PICylo,x		;find row offset - mult. y/32 * mapwidth	lsr a	lsr a	lsr a	lsr a	lsr a		;/32	sta WRMPYA			;multiplicand	lda mapwidth	sta WRMPYB			;multiplier		lda RDMPYL			;get results	sta tmp	lda RDMPYH	sta tmp+1		lda map+1	clc	adc tmp+1		;add high byte of multiply result	sta temp+1	lda map	clc	adc tmp		;add low of multiply result	bcc @overflow		inc temp+1		;inc high again	@overflow:	sta temp		;check for offscreen collisions	lda PICxhi,x	beq @checkyhi		;not off for x		bmi @leftoff	@rightoff:	lda temp	clc	adc #8	sta temp	bcc @rightoffadd	inc temp+1@rightoffadd:	bra @checkyhi@leftoff:	lda temp	sec	sbc #8	sta temp	bcs @leftoffadd	dec temp+1@leftoffadd:@checkyhi:		;look for offscreen y values	lda PICyhi,x	beq @onscreen 		;not off for x	bmi @topoff@bottomoff:			;off bottom of screen	lda #8	sta WRMPYA			;multiplicand	lda mapwidth	sta WRMPYB			;multiplier		lda temp+1	clc	adc RDMPYH		;add high byte of multiply result	sta temp+1	lda temp	clc	adc RDMPYL		;add low of multiply result	sta temp	bcc @bo1		inc temp+1	@bo1:	bra @onscreen@topoff:	 		;off top of screen	lda #8	sta WRMPYA			;multiplicand	lda mapwidth	sta WRMPYB			;multiplier		lda temp+1	sec	sbc RDMPYH		;add high byte of multiply result	sta temp+1	lda temp	sec	sbc RDMPYL		;add low of multiply result	sta temp	bcs @bo2		dec temp+1	@bo2:	@onscreen:		lda temp	clc	adc temp+4			;xoffset	sta temp	bcc @a2	inc temp+1@a2:;must restore original PIC positions now	pla	sta PICyhi,x	pla	sta PICxhi,x	pla	sta PICylo,x	pla	sta PICxlo,x		;now calculate location WITHIN block	lda PICxlo,x	clc	adc blockcounth	clc	adc temp+2	lsr a	lsr a	and #%00000110	sta temp+4			;holds char. xoffset within block		lda PICylo,x	clc	adc temp+3	clc	adc blockcountv	and #%00011000	clc	adc temp+4	sta temp+4			;now holds char offset within block 	ldy #0	jsr getblockaddr	;find block contents address	ldx TSKcurrent		lda blockpage	pha	plb		ldy temp+4	lda (blockaddr),y	sta whichchar					;tmp now holds the collision character	iny	lda (blockaddr),y	and #%1	sta whichchar+1		jsr	charactertype		plb	rts** ACC=X offset (+-128) Y=Y offset (+-128)*bgcoll:		sta collxoff	sty collyoff				*	first test for offscreen points		lda collxoff	bpl	@xp		; Is X offset positive@@xn:	eor	#255	clc	adc	#1		; Otherwise negate it!	sta	tmpx	lda	PICxlo,x	; Where we are	sec	sbc	tmpx	sta tmpx	bcs @xok	jmp @exit	@xp:	lda PICxlo,x	clc	adc collxoff	sta tmpx	bcc @xok		jmp @exit	@xok:	lda collyoff	bpl	@yp		; Is Y offset positive@@yn:	eor	#255	clc	adc	#1		; Otherwise negate it!	sta	tmpy	lda	PICylo,x	; Where we are	sec	sbc	tmpy	sta tmpy	bcs @yok	jmp @exit	@yp:	lda PICylo,x	clc	adc collyoff	sta tmpy	bcc @yok	@gotoexit:	jmp @exit	@yok:	lda tmpx	cmp #16	bcc @gotoexit	cmp #256-16	bcs @gotoexit		lda tmpy	cmp #16	bcc @gotoexit	cmp #256-16	bcs @gotoexit* now do normal stuff...@normal:;	jsl	PICyunflip		lda collxoff;	sec;	sbc	#32			;system fudge	pha	lda	mapcounth	and	#7	asl	a	asl	a	asl	a	asl	a	asl	a	clc	adc	blockcounth	sta	tmp             ; tmp=put buffer offset	pla	ora	#0	bpl	@xop		; Is X offset positive@	eor	#255	clc	adc	#1		; Otherwise negate it!	sta	tmpx	lda	PICxlo,x	; Where we are	sec	sbc	tmpx		pha	lda	PICxhi,x	sbc	#0	beq	@onscreenh	pla	lda	#0	rts	@onscreenh:	pla	clc	adc	tmp		; Add put buffer offset			pha	and	#7	sta	imbedx	pla	lsr	a	lsr	a		; Convert to word offset	and	#$fe	sta	tmpx	bra	@xon@xop:	clc	adc	PICxlo,x	pha	lda	PICxhi,x	adc	#0	beq	@onscreen1	pla	lda	#0	rts@onscreen1:	pla	clc	adc	tmp		pha	and	#7	sta	imbedx	pla		lsr	a	lsr	a		; Convert to word offset	and	#$fe	sta	tmpx@xon:	lda	mapcountv	and	#7	asl	a	asl	a	asl	a	asl	a	asl	a	clc	adc	blockcountv	sta	tmp	tya			; Get Y offset into accumulator	ora	#0	bpl	@yop		; Is X offset positive@	eor	#255	clc	adc	#1		; Otherwise negate it!	sta	tmpy	lda	PICylo,x	; Where we are	sec	sbc	tmpy	pha	lda	PICyhi,x	sbc	#0	bne	@offscreen	pla	clc	adc	tmp		pha	and	#7	sta	imbedy	pla		SET16	and	#$f8		; Mask off lower 3 bits	asl	a	asl	a	asl	a	clc	adc	#$1300	sta	tmpy		; Convert to vertical offset	bra	@yon	SET8@yop:	clc	adc	PICylo,x	pha	lda	PICyhi,x	adc	#0	bne	@offscreen	pla	clc	adc	tmp		pha	and	#7	sta	imbedy	pla		SET16	and	#$f8		; Mask off lower 3 bits	asl	a	asl	a	asl	a	clc	adc	#$1300		; We're looking into the put screen.	sta	tmpy		; Convert to vertical offset@yon:	SET8		ldy	tmpx	lda	(tmpy),y	sta whichchar					;tmp now holds the collision character	iny	lda (tmpy),y	and #%1	sta whichchar+1	jsr	charactertype	rts	@offscreen:	pla	lda	#0	rts	@exit:	lda collxoff	ldy collyoff	jmp collide	** scan the map*xm	lda	tmpx	sec	sbc	#2	and	#63	sta	tmpx	tay	lda	(tmpy),y	sta whichchar					;tmp now holds the collision character	iny	lda (tmpy),y	and #%1	sta whichchar+1	jsr	charactertype	rts	xp:	lda	tmpx	clc	adc	#2	and	#63	sta	tmpx	tay	lda	(tmpy),y	sta whichchar					;tmp now holds the collision character	iny	lda (tmpy),y	and #%1	sta whichchar+1	jsr	charactertype	rts	ym:	SET16	lda	tmpy	sec	sbc	#64	cmp	#$1300	bcs	@nowrap	clc	adc	#2048@nowrap:	sta	tmpy	SET8	ldy	tmpx	lda	(tmpy),y	sta whichchar					;tmp now holds the collision character	iny	lda (tmpy),y	and #%1	sta whichchar+1	jsr	charactertype	rts	yp:	SET16	lda	tmpy	clc	adc	#64	cmp	#2048+$1300	bcc	@nowrap	sec	sbc	#2048@nowrap:	sta	tmpy	SET8	ldy	tmpx	lda	(tmpy),y	sta whichchar					;tmp now holds the collision character	iny	lda (tmpy),y	and #%1	sta whichchar+1	jsr	charactertype	rts		