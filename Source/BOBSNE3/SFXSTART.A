** Super Famicom system routines*	** initiate VRAM DMA download to screen 1*DMAdownload	proc	lda	staticintro		;no scroll update for dad or diner...	beq	@go	rts@go:	stz	VMADDL		; vram low	stz	VMADDH		; vram high	stz	HDMAEN		; turn off h-dma	lda	#%00000001	sta	$4300			; dma mode	lda	#<VMDATAWL		; which channel for DMA	sta	$4301			; b-bus addr	lda	#0		; cleared (hopefully)	sta	$4302			; a-bus low addr	lda	#>screenram		; RAM source-(put),y	sta	$4303			; a-bus high addr	lda	#0	sta	$4304			; bank #	lda	#0	sta	$4305			; # of bytes low	lda	#8			; $800 bytes (screen size)	sta	$4306			; # of bytes high	lda	#1	sta	MDMAEN		; turn on dma	rts		** clear all vram (screens)*		assume ram is zeroed*clearscreens:	lda	#ForcedBlankOn		;turn off vertical blank	sta	INIDISP	lda	#0	ldy	#0	jsr	drawscreen		lda	#0	ldy	#1	jsr	drawscreen	clearscreen3:	lda	#0	ldy	#2	jsr	drawscreen		lda	#ForcedBlankOff	;turn off vertical blank	sta	INIDISP		rts	** draw 8x8 on a screen*	a has picnumber*	y has screen number*drawscreen:	sta	temp	sty	temp+1@compress:	lda	temp	asl	a	asl	a	tay	lda	titlescreens,y	sta	tmpd		;$4302			;source low	iny	lda	titlescreens,y	sta	tmpd+1	;$4303			;source high	iny	lda	titlescreens,y	sta	tmpd+6	;$4304			;source page	lda	#$7f	sta	tmpd+7		lda	temp	asl	a	tay	lda	etitlescreens,y	sta	tmpd+2	iny	lda	etitlescreens,y	sta	tmpd+3		lda	#0	sta	tmpd+4	sta	tmpd+5		jsl	decomp		lda	#0				;anim data lo	sta	$4302			; a-bus low addr	lda	#0				;anim data hi	sta	$4303			; a-bus high addr		lda	#$7f	sta	$4304			; bank #			lda	temp+1	asl	a	tay	lda	screenaddress,y	sta	VMADDL		;dest addr lo	iny		lda	screenaddress,y	sta	VMADDH		;dest addr hi		stz	HDMAEN		; turn off h-dma	lda	#%00000001	sta	$4300			; dma mode	lda	#<VMDATAWL		; which channel for DMA	sta	$4301			; b-bus addr	lda	#0	sta	$4305			; # of bytes low	lda	#8			; $800 bytes (screen size)	sta	$4306			; # of bytes high	lda	#1	sta	MDMAEN		; turn on dma	rts	** Load a character set into vram*PartFillbgchar	sta	tmp	sty	tmp+1		;source	lda	#1	sta	temp+3	;no loop	bra	Dobgfill	FillBGCharacter	PROC	sta	tmp		;set source	sty	tmp+1	stz	temp+4Dobgfill:	lda	temp		;bank	pha	plb			lda	temp+1		;set VRAM destination	sta	VMADDL	lda	temp+2	sta	VMADDH	@preloop:	ldx	temp+4	;#0		; character count@catLoop	phx	ldx	#16		;dump 32 bytes@cat1	ldy	#0 		;low	lda	(tmp),y	sta	VMDATAWL	ldy	#1 		;hi	lda	(tmp),y	sta	VMDATAWH		lda	tmp	clc	adc	#2	bcc	@nowrap	inc	tmp+1@nowrap:	sta	tmp	dex	bne	@cat1	plx			;dump 256 characters	dex	bne	@catLoop		inc	temp+3	;do it twice	lda	temp+3	cmp	#2	bcc	@preloop	lda	#0	pha	plb		rts		** Load 256+96 chars*	FillBGCharacterx	PROC	sta	tmp		;set source	sty	tmp+1	stz	temp+4	lda	temp		;bank	pha	plb			lda	temp+1		;set VRAM destination	sta	VMADDL	lda	temp+2	sta	VMADDH** dump first 256*@preloop:	ldx	#0		; character count@catLoop	phx	ldx	#16		;dump 32 bytes@cat1	ldy	#0 		;low	lda	(tmp),y	sta	VMDATAWL	ldy	#1 		;hi	lda	(tmp),y	sta	VMDATAWH		lda	tmp	clc	adc	#2	bcc	@nowrap	inc	tmp+1@nowrap:	sta	tmp	dex	bne	@cat1	plx			;dump 256 characters	dex	bne	@catLoop	** load the other 96*	ldx	#95		; character count@catLoop2	phx	ldx	#16		;dump 32 bytes@cat2:	ldy	#0 		;low	lda	(tmp),y	sta	VMDATAWL	ldy	#1 		;hi	lda	(tmp),y	sta	VMDATAWH		lda	tmp	clc	adc	#2	bcc	@nowrap2	inc	tmp+1@nowrap2:	sta	tmp	dex	bne	@cat2	plx			;dump 96	dex	bne	@catLoop2		lda	#0	pha	plb		rts	** fetch sprite pal 1 only*whichcarpal:	dc.w worldsprpal2	dc.w worldsprpal3	dc.w worldsprpalgetfamily1:	lda	world	asl	a	tay	lda	whichcarpal,y	sta	tmp	lda	whichcarpal+1,y	sta	tmp+1		lda	#$80+$10		;point to	sta	CGADD				phb	lda	#6	pha	plb		ldy	#32@0:	lda	(tmp),y	;dump 32 bytes	sta	CGDATAW	iny	lda	(tmp),y	;get high	sta	CGDATAW	;write	iny	cpy	#64	bne	@0	plb	rts		** copy pallete 7 to pallete 3 (for rezzin)*copy7to3:	phb			lda	#<lastpal7	sta	tmp	lda	#>lastpal7	sta	tmp+1		lda	#6	pha	plb	lda	#$80+$30		;point to	sta	CGADD			;spr family 3 dest		ldy	#0@0:	lda	(tmp),y	;dump 32 bytes	sta	CGDATAW	iny	lda	(tmp),y	;get high	sta	CGDATAW	;write	iny	cpy	#32	bne	@0		plb	rts	** restore palette 3*restorepal3:	phb		lda	#0			;arrggh	pha	plb		lda	mapnumber	asl	a	tay	lda	whichpalletes,y	asl	a	asl	a	tay	lda	spritepalletes,y	sta	tmp			;addr hi	iny	lda	spritepalletes,y	sta	tmp+1			;addr lo	iny	lda	spritepalletes,y	;page	pha	plb	SET16	lda	tmp			;point to 	clc				;family 3 source	adc	#48*2	sta	tmp	SET8	lda	#$80+$30		;point to	sta	CGADD			;spr family 3 dest		ldy	#0@0:	lda	(tmp),y	;dump 32 bytes	sta	CGDATAW	iny	lda	(tmp),y	;get high	sta	CGDATAW	;write	iny	cpy	#32	bne	@0		plb	rts		** color cycling shit*tongepal: dc.w $66F9 dc.w $416Ftongepal2: dc.w $031F		;cycle!!! dc.w $02F9 cycleworld2colors:	dc.w $0001 	dc.w $0003 	dc.w $0005 	dc.w $0007 	dc.w $001F world2order:	dc.b	0,1,2,3,4,0,0,0	dc.b	1,2,3,4,0,0,0,0	dc.b	2,3,4,0,1,0,0,0	dc.b	3,4,0,1,2,0,0,0	dc.b  4,0,1,2,3,0,0,0	cycleworld1colors: 	dc.w $001d 	dc.w $0010 	dc.w $0005world1order:	dc.b	0,1,2,0	dc.b	2,0,1,0	dc.b	1,2,0,0	deathcolors:	dc.w $027F 	dc.w $01DA 	dc.w $0155 	dc.w $00EF 	dc.w $008Acycletonge:	lda	cputime	and	#2	asl	a	tax		lda	#128+(16*4)+13	sta	CGADD		ldy	#0@0:	lda	tongepal,x	;get low	sta	CGDATAW	inx	lda	tongepal,x	;get high	sta	CGDATAW	;write	inx	iny	cpy	#4	bne	@0	ldx	TSKcurrent	rts	cycledeath:	lda	lockscreen	beq	@noway	lda	TSKclock	and	#3	cmp	#3	beq	@gogadget@noway:	rts@gogadget:	lda	#128+(16*3)+11	sta	CGADD	stz	temp		lda	cyclecount	inc	a	cmp	#5	bcc	@fine	lda	#0@fine:	sta	cyclecount	asl	a	asl	a	asl	a	tay	@loop:	lda	world2order,y	iny	asl	a	tax	lda	deathcolors,x	sta	CGDATAW	inx	lda	deathcolors,x	sta	CGDATAW	lda	temp	inc	a	cmp	#5	bcs	@done	sta	temp	bra	@loop@done:	ldx	TSKcurrent	rts	cycleworld2:	lda	TSKclock	and	#7	cmp	#7	beq	@gogadget	rts@gogadget:	lda	#(16*3)+2	sta	CGADD	stz	temp		lda	cyclecount	inc	a	cmp	#5	bcc	@fine	lda	#0@fine:	sta	cyclecount	asl	a	asl	a	asl	a	tay	@loop:	lda	world2order,y	iny	asl	a	tax	lda	cycleworld2colors,x	sta	CGDATAW	inx	lda	cycleworld2colors,x	sta	CGDATAW	lda	temp	inc	a	cmp	#5	bcs	@done	sta	temp	bra	@loop@done:	ldx	TSKcurrent	rts			monitorcolor:	lda	world	cmp	#1	beq	cycleworld2	** world 1 cycle:*	lda	TSKclock	and	#3	cmp	#3	beq	@gogadget	rts@gogadget:	lda	#(16*7)+4	sta	CGADD	stz	temp		lda	cyclecount	inc	a	cmp	#3	bcc	@fine	lda	#0@fine:	sta	cyclecount	asl	a	asl	a	tay	@loop:	lda	world1order,y	iny	asl	a	tax	lda	cycleworld1colors,x	sta	CGDATAW	inx	lda	cycleworld1colors,x	sta	CGDATAW	lda	temp	inc	a	cmp	#3	bcs	@done	sta	temp	bra	@loop@done:	ldx	TSKcurrent	rts		** fill 128 colors...*fill128:	ldy	#0@0:	lda	(tmp),y	;get low	sta	CGDATAW	iny	lda	(tmp),y	;get high	sta	CGDATAW	;write	iny	bne	@0	rtsfill128not:	ldy	#0@0:	lda	(tmp),y	;get low	sta	CGDATAW	iny	lda	(tmp),y	;get high	sta	CGDATAW	;write	iny	cpy	#256-40	bne	@0	rtsfill20:	ldy	#0@0:	lda	(tmp),y	;get low	sta	CGDATAW	iny	lda	(tmp),y	;get high	sta	CGDATAW	;write	iny	cpy	#40	bne	@0	rtsfill32:	ldy	#0@0:	lda	(tmp),y	;get low	sta	CGDATAW	iny	lda	(tmp),y	;get high	sta	CGDATAW	;write	iny	cpy	#64	bne	@0	rts	;Name:	SetUpBackgrounds;Function:	Sets PPU registers for Background data;Inputs:	None.;Outputs:	None.SetUpBackgrounds	PROC	lda	#BG18X8+BG28X8+BG38X8+BG3HI+BGMode1;;	lda 	#7+bg3hi			;*** christine	sta	BGMODE		;background mode			lda	#$22			;character location...	sta	BG12NBA	lda	#$66	sta   BG34NBA		lda	#$0+BGSize1X1	;screen size	sta	BG1SC	lda	#$8+BGSize1X1	sta	BG2SC	lda	#$10+BGSize1x1	sta	BG3SC		lda	#BG1MainOff+BG2MainOff+BG3MainOff+ObjMainOff	sta	TM	 		;main/sub designation		lda	#BG1SubOn+BG2SubOff+BG3SubOff+ObjSubOff	sta	TS			;sub on/off;;	lda #10000000;;	sta $211a		;m7select	 	;make area outside nothingness		rts	** turn on  control panel window mask*turnonwindows:		lda	#%11111111	sta	W12SEL		;cover screens 1 and 2	lda	#%00000011	sta	W34SEL		;cover panel on inside			lda	#%00000011					sta	WOBJSEL		;cover objects		lda	#8			;left			sta	WH0	lda	#-8			;right	sta	WH1		lda	#%00011111	sta	TMW		lda	#%00000000	sta	WBGLOG	lda	#%00000000	sta	WOBJLOG			rtsturnoffwindows:	lda	#0	sta	W12SEL	sta	W34SEL	sta	WOBJSEL	sta	TMW	lda	#BG1MainOn+BG2MainOn+BG3MainOff+ObjMainOn	sta	TM	 		;main/sub designation	lda	#0			;left			sta	WH0	lda	#255			;right	sta	WH1			rts	** Name:	SetUpObjects* Function:	Sets PPU registers to point to Object Data and sets Object Size* Inputs:	None.* Outputs:	None.*SetUpObjects	PROC	lda	#Obj8X16+ObjArea1+ObjBase4 ;0	sta	OBJSEL			;object size/location	lda	#ObjVOff+%0000000		;no interlace, 239 scan lines	sta	SETINI	lda	#$0				;set vram pointer ($00)	sta	OAMADDL	sta	OAMADDH	ldx	#$0				;clear first 256 sprites	txa@0		sta	OAM_DATA	sta	OAM_DATA	sta	OAM_DATA	sta	OAM_DATA	dex	bne	@0		lda	#1				;set vram to $1000	sta	OAMADDH	lda	#0	sta	OAMADDL	ldx	#$0f				;set size of sprite (1x1)	lda	#$55@1	sta	OAM_DATA	sta	OAM_DATA	dex	bpl	@1	rts		** fade in*dofadein:	lda	#-1	sta	xmosaic	lda	#15	sta	mosaiccounterdofadein2:		lda	#1	sta	fade	lda	#0	sta	fadecounter	rts	** fade out*dofadeout:		lda	#-1	sta	fade	lda	#15	sta	fadecounter	rts	dofademosaicout:		lda	#-1	sta	fade	lda	#15	sta	fadecounter	lda	#1	sta	xmosaic	lda	#0	sta	mosaiccounter	rts	** make screen go to/return from black*cutblack:	lda	#0	sta	INIDISP	lda	#BG1MainOff+BG2MainOff+BG3MainOff+ObjMainOff	sta	TM			rts	endblack1:	lda	#15	sta	INIDISPendblack1a:	lda	#BG1MainOff+BG2MainOn+BG3MainOn+ObjMainOn	sta	TM			rtsendblack2:	lda	#15	sta	INIDISP	lda	#BG1MainOn+BG2MainOn+BG3MainOn+ObjMainOn 	sta	TM			rts** zero user ram*ZeroRam	PROC	SET16	ldx	#0@loop1	stz	$0,x	inx	inx	cpx	#$100	bne	@loop1		ldx	#0@loop2:	stz	$400,x	inx	inx	cpx	#$1a00	;clear 200-1fff;	bne	@loop2	SET8	rtsZero2:	lda	#ForcedBlankOn			sta	INIDISP	SET16	ldx	#0	txa@loop3	sta	$7e2000,x	;clear 7e2000-7e7fff	inx	inx	cpx	#$800	bne	@loop3	SET8	lda	#ForcedBlankOff			sta	INIDISP	rts