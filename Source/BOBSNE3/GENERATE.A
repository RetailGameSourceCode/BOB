***		MAP BASED TASK GENERATION**mingen		equ	10maxgen		equ	22allxoff		equ	13-8allyoff		equ	0generate_left_enemies:	lda blockcounth		;only create in centre of block	cmp #mingen	bcc exit_generate	cmp #maxgen 	bcs exit_generate	lda #-16+allxoff		;20	ldy #-16	jsr enxyset	lda #-1	ldy #-1	jsr enxyhiset	lda #0			;initial offset	jmp lookatside		;jmp above to finish lookingexit_generate:	rtl	;sgenerate_right_enemies:	;routine to generate enemies from map data	lda blockcounth		;only create between pixels 15 & 16	cmp #mingen	bcc exit_generate	cmp #maxgen	bcs exit_generate	lda #16+allxoff		ldy #-16	jsr enxyset	lda #1	ldy #-1	jsr enxyhiset	lda #9			;initial offsetlookatside:	jsr settmpmaph		;init pointers	jsr down1		;down a row at a time	jsr down1		;...	jsr down1		;...	jsr down1			jsr down1		;...	jsr down1		;...	jsr down1		;...	jsr down1		;...	jsr	down1	rtl		      ;follow through for last onedown1:	lda mapwidth	jsr temp_add	lda eny	clc	adc #32	sta eny	bcc @d1	inc enyhi@d1:	jsr plotenemy	rtsexit_generatev:	rtl		;--------------------------generate_top_enemies:	lda blockcountv		;only create between pixels 31 & 32	cmp #mingen	bcc exit_generatev	cmp #maxgen	bcs exit_generatev	lda #-16+allxoff				ldy #-16					jsr enxyset	lda #-1	ldy #-1	jsr enxyhiset	lda #0			;initial offset	jsr settmpmapv		;init pointers	jmp lookattop		;jmp to finish lookinggenerate_bottom_enemies: 	lda blockcountv		;only create between pixels 31 & 32	cmp #mingen	bcc exit_generatev	cmp #maxgen	bcs exit_generatev	lda #-16+allxoff				ldy #16				jsr enxyset	lda #-1	ldy #1	jsr enxyhiset	jsr taskmapaddr		lda mapwidth	jsr temp_add	lda mapwidth	jsr temp_add	lda mapwidth	jsr temp_add	lda mapwidth	jsr temp_add	lda mapwidth	jsr temp_add	lda mapwidth	jsr temp_add	lda mapwidth	jsr temp_add	lda mapwidth	jsr temp_add	lda mapwidth	jsr settmpmapv2		;init pointerslookattop:	jsr right1		;across 1 column at a time	jsr right1		;...	jsr right1		;...	jsr right1		;...	jsr right1		;...	jsr right1		;...	jsr right1		;...	jsr right1		;...	      ;follow through...	jsr	right1	rtl	right1:	lda #1	jsr temp_add	lda enx	clc	adc #32	sta enx	bcc @r1	inc enxhi@r1:	jsr plotenemy	rts		;--------------------------settmpmaph:	pha	jsr taskmapaddr    pla		jsr temp_add		;set initial position	jsr plotenemy		;setup enemy on this spot if valid		rtssettmpmapv:	pha	jsr taskmapaddr			;set task map	    plasettmpmapv2:	jsr temp_add		;set initial position	jsr plotenemy		;setup enemy on this spot if valid	rts;--------------------------------------enxyset:	sta enx	sty eny	rtsenxyhiset:	sta enxhi	sty enyhi	rts;-----------------------------------------------------------------plotenemy:		;routine to search for enemy block origin	phb	pla	sta tmp+7			;save dbr		lda	bobready	bne	@go	jmp	@noenemy@go:	lda #$7e	pha	plb		ldy #0	lda (temp),y		;look at block value	bne @task_block	@goto_out	jmp @out_of_tasks		;<>0 means something's there...	@task_block:	sta tmp	and #%10000000		;bit 7 set means task is active here so avoid	bne @goto_out		;active task so exit	@not_active:			;can turn this baby on so check it out	lda tmp+7	pha	plb			lda tmp	sta	newtask		sta WRMPYA			;multiplicand	lda #7	sta WRMPYB			;multiplier		;size of data per entry		nop	nop	nop	nop	lda RDMPYH	;<16*7		;RDMPYL	sta tmp+5	lda RDMPYL	;>16*7		;RDMPYH	sta tmp+4		lda tmp+5	clc	adc taskmaptable+1		;add base table hi byte	sta tmp+3		lda tmp+4	clc	adc taskmaptable		;add base table lo byte	sta tmp+2	bcc @grabit		inc tmp+3	@grabit	ldy #0		phb	lda	#22	pha	plb		lda (tmp+2),y		;copy task addr for TSKschedule2	sta tmp	iny	lda (tmp+2),y		;addr high	sta tmp+1	iny	lda (tmp+2),y		;task type reference	sta tasktype	iny	lda (tmp+2),y		;task specific variable setting	sta tempflag	iny	lda (tmp+2),y	sta tmpx	iny	lda (tmp+2),y	sta tmpy	iny	lda (tmp+2),y	sta tempbank	plb	jsl TSKschedule3		;shedule item	bcs @settask		jmp @out_of_tasks		;not successful@settask:		;fill new task with correct x,y, etc...	tax				lda #$7e	pha	plb		ldy #0				;activate task map block...	lda (temp),y	ora #%10000000		;set high bit of this task - now ACTIVE	sta (temp),y			;now add this task addr to enemy map table	lda temp	sta PICmaplo,x		;save off this task's original map location	lda temp+1	sta PICmaphi,x		lda tempflag	sta PIClogic,x		;special temp flag - use for any old thing...		lda #0			;2	sta PICscroll,x		lda enx	sta PICxlo,x	lda eny	sta PICylo,x	lda enxhi	sta PICxhi,x	lda enyhi	sta PICyhi,x**	line up task with current scroll offsets*	lda blockcounth	beq @bonk1	jsl PICxsub@bonk1:	lda blockcountv	beq @bonk2	jsl PICysub@bonk2:	lda 	alternate	and 	#1	beq 	@outofsink	jsr sink@outofsink	***	lda tmpx				;adjust for x offset	beq @nox_off	jsl PICxadd	@nox_off:	lda tmpy				;adjust for y offset	beq @noy_off	jsl PICyadd	@noy_off:@out_of_tasks:@noenemy:	ldx TSKcurrent		lda tmp+7	pha	plb			rts	temp_add	proc			;universal temp add	sta tempadd		lda temp	clc	adc tempadd	sta temp	bcc @ta1		inc temp+1	@ta1:	rts***temp_sub	proc			;universal temp subtract	sta tempadd		lda temp	sec	sbc tempadd	sta temp	bcs @ts1		dec temp+1	@ts1:	rts**		create task map addr based upon current scroll map addr*	taskmapaddr		proc	lda map+1			;set current task map addr (based on map addr)	clc	adc #>mapsize+512	sta temp+1		lda map				;set low	sta temp		lda #1	jsr temp_sub		lda mapwidth	jsr temp_sub		rts					;temp now holds current addr within task map;--------------------------------------------------------------sink:	lda enemy_leftscroll	beq @tryright		jsl	PICxsub		;move task	bra @tryup	@tryright	lda enemy_rightscroll	beq @tryup		jsl PICxadd			;move task	@tryup	lda enemy_upscroll	beq @trydown		jsl PICysub			;move task	bra @nosync	@trydown	lda enemy_downscroll	beq @nosync		jsl PICyadd			;move task	@nosync:	rts			** kevin collisions*bgcoll_longer:		ora	#0		; Test if X offset + or -	bpl	@posxoff	eor	#255	inc	a		; Negate offset	sta	temp	lda	PICxlo,x	sec	sbc	temp	sta	tmp	lda	PICxhi,x	sbc	#0	sta	tmp+1	bra	@xdone@posxoff:	clc	adc	PICxlo,x	sta	tmp	lda	PICxhi,x	adc     #0	sta	tmp+1		; tmp=PICx+X offset@xdone:	lda	tmp	clc	adc	blockcounth	sta	tmp	bcc	@nocarry	; tmp=Xcoordinate+blockcounth	inc	tmp+1@nocarry:	tya	ora	#0		; Test if Y offset + or -	bpl	@posyoff	eor	#255	inc	a		; Negate offset	sta	temp	lda	PICylo,x	sec	sbc	temp	sta	tmp+2	lda	PICyhi,x	sbc	#0	sta	tmp+3	bra	@ydone@posyoff:	clc	adc	PICylo,x	sta	tmp+2	lda	PICyhi,x	adc     #0	sta	tmp+3		; tmp=PICx+X offset@ydone:	lda	tmp+2	clc	adc	blockcountv	sta	tmp+2	bcc	@nocarry1	; tmp=Xcoordinate+blockcounth	inc	tmp+3@nocarry1:	SET16	lda	tmp+2		; Y pixel value	bpl	@posval		; First divide by 32	lsr	a	lsr	a	lsr	a	lsr	a	lsr	a		; /32	ora	#61440		; Add in negative stuff	bra	@negval@posval:	lsr	a	lsr	a	lsr	a	lsr	a	lsr	a		; /32@negval:	sta	temp+2		; temp+2=Y/32	lda	tmp		; Y pixel value	bpl	@posval1	; First divide by 32	lsr	a	lsr	a	lsr	a	lsr	a	lsr	a		; /32	ora	#61440		; Add in negative stuff	bra	@negval1@posval1:	lsr	a	lsr	a	lsr	a	lsr	a	lsr	a		; /32@negval1:	sta	temp		; temp=X/32	SET8	lda	temp+2		; Y map block position	sta 	WRMPYA		; multiplicand	lda 	mapwidth	sta 	WRMPYB		; multiplier		;block number * 32 chars	nop	nop	nop	nop	nop	nop	nop	nop	lda 	RDMPYL	clc	adc	temp		; X block offset	sta 	temp+2	lda 	RDMPYH	adc	#0	sta 	temp+3	     	; temp+2=Total map offset	lda	temp+2	clc	adc	map	sta	temp+2	lda	temp+3	adc	map+1	sta	temp+3		; temp+2=Map block pointer	phb	lda	#$7e		; Map bank	pha	plb	lda	(temp+2)	; Which block is it@	plb	sta	temp		; temp=block piece	stz	temp+1	phb	lda	blockpage	pha	plb	SET16	lda	temp		; Block #	asl	a	asl	a	asl	a	asl	a	asl	a	        ; x32	clc	adc	blockaddress	; +location of blockset	sta	temp		; temp=pointer to block	lda	tmp		; X pixel	and	#24		; within block - LSB 3 bits	lsr	a	lsr	a		; which character within block	clc	adc	temp	sta	temp		; Update block pointer	lda	tmp+2		; Y pixel	and	#24		; within block - LSB 3 bits	clc	adc	temp	sta	temp		; Update block pointer	lda	(temp)		; This is the charater!	and	#511	sta	temp		; temp=result	SET8		lda temp	sta whichchar					;tmp now holds the collision character	lda temp+1	sta whichchar+1		jsl charactertype_long	plb			; Set to bank 0	rtl	** bobs eyes on title screen*eyeframes:	dc.b 0,0,0,0,0,1,2,2,2,2,2,2,2,2,2,2,2,2,2	dc.b 2,2,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0	eyeframes2:	dc.w	eyeframe2	dc.w	eyeframe0	dc.w	eyeframe1bobseyes:	lda	#1	sta	PICbank,x		lda	#6	sta	PICcolor,x		lda	#88	sta	PICxlo,x		lda	#52-25		;+2 is a chris fix	sta	PICylo,x		jsl	TSKsuspend	lda	introflag	bne	@nodie	jml	TSKcancel@nodie:		lda	TSKclock	and	#7	cmp	#7	bne	@noinceyes	inc	doorcounter@noinceyes:	lda	doorcounter	and	#31	tay	lda	eyeframes,y	asl	a	tay	lda	eyeframes2,y	sta	tmp	lda	eyeframes2+1,y	sta	tmp+1	jsl	PICput2	rtl	bobsgun:	lda	#1	sta	PICbank,x		lda	#6	sta	PICcolor,x		lda	#80	sta	PICxlo,x		lda	#97-25			;+2 is chris fix	sta	PICylo,x		jsl	TSKsuspend	lda	introflag	bne	@nodie	jml	TSKcancel@nodie:	jsl	PICput	dw	gunframe	rtleyeframe0: dc.b $04 dc.b $89,$8D,$24 dc.b $D7,$8D,$20 dc.b $C7,$8D,$22 dc.b $C7,$C3,$02eyeframe1: dc.b $06 dc.b $89,$8D,$64 dc.b $C7,$8D,$62 dc.b $D7,$8D,$60 dc.b $89,$C3,$44 dc.b $D7,$C3,$40 dc.b $C7,$C3,$42eyeframe2: dc.b $01 dc.b $C7,$C3,$02 gunframe: dc.b $0A dc.b $84,$81,$2A dc.b $94,$81,$2C dc.b $A4,$81,$2E dc.b $A4,$CF,$0E dc.b $94,$CF,$0C dc.b $84,$CF,$0A dc.b $CC,$81,$28 dc.b $DC,$81,$26 dc.b $DC,$CF,$06 dc.b $CC,$CF,$08** dummy scooter*shakevals2:	dc.b	-1,1,0,1,-1,0,1,-1testscooter:	stz	scooterwin		lda	#4	sta	PICbank,x		lda	#1	sta	PICscroll,x	lda	#5	sta	PICcolor,x	sta	PICprior,x		lda	#type_enemy	jsl	TSKschedule	dw	scootflames	tay	lda	#1	sta	TSKbank,y		lda	#type_generic	sta	PICtype,x		lda	#-16	jsl	PICyadd		jsl	TSKsuspend	lda	scooterwin	beq	@nowin	jsr	providepoints	rtl@nowin:	lda	strength	bne	@alive	lda	#1	jml	doexplosion@alive:	jsr	drawscooter		;always draw	lda	status			cmp	#drivescooter	;if bob is inside...go along for the ride	bne	@notin		lda	walkdir	bpl	@negway	lda	bobxpos;	clc;	adc	#8	sta	PICxlo,x	rtl@negway:	lda	bobxpos;	sec;	sbc	#8	sta	PICxlo,x	rtl	@notin:	lda	PICcount,x	inc	a	sta	PICcount,x	and	#7	tay	lda	shakevals2,y	jsl	PICyadd		lda	PICxhi,x		;else wait for bob to jump in..	ora	PICyhi,x	bne	@off	lda	PICxlo,x	cmp	#126	bcc	@off	cmp	#132	bcs	@off	lda	PICylo,x	cmp	#90	bcc	@off	cmp	#110	bcs	@off	lda	#drivescooter	sta	status	stz	PICscroll,x	lda	bobxpos	sta	PICxlo,x	lda	bobypos	sta	PICylo,x	lda	#faceright	sta	walkdir@off:	rtl	** sub-routine to draw scooter body*drawscooter:	lda	status	cmp	#drivescooter	bne	@noturn		lda	turncount	beq	@noturn	lda	walkdir	bmi	@faceleft@faceright:	lda	turncount	cmp	#2	bne	@noflip2	jsl	PICxflip	bra	@noflip3@faceleft:	lda	turncount	cmp	#1	bne	@noflip2	jsl	PICxflip	bra	@noflip3@noflip2:	lda	#0	sta	PICattr,x@noflip3:	lda	#5	bne	@drawscoot	** ok...draw the bastard*@noturn:	lda	#4@drawscoot:	asl	a	tay	lda	scootframes,y	sta	tmp	iny	lda	scootframes,y	sta	tmp+1	jsl	PICput2	rts	** scooter frames*scootframes:				;in weapfr.asm	dc.w	scooterframe0	dc.w	scooterframe1	dc.w	scooterframe2	dc.w	scooterframe3	dc.w	scooterframe4	dc.w	scooterframe5	dc.w	scooterframe6	dc.w	scooterframe7** scooter flames*scootflames:	lda	strength	bne	@alive	jmp	TSKcancel@alive:	lda	#7	sta	PICcolor,x		lda	#0	sta	PICattr,x	sta	PICtype,x		lda	#4	sta	PICbank,x		ldy	whichbigship	lda	PICxlo,y	sta	PICxlo,x	lda	PICylo,y	sta	PICylo,x	lda	walkdir	bpl	@fine	jsl	PICxflip	lda	#4	bra	@setfla@fine:	lda	#-4@setfla:;	jsl	PICxadd		lda	accelflames	bne	@drawflame@noflame:	lda	#0	sta	PICadrLo,x	sta	PICadrHi,x	rtl@drawflame:	lda	TSKclock	and	#31	cmp	#31	bne	@nosound	lda	#SFXSCOOTER	jsl	soundeffects@nosound:	stz	accelflames	lda	turncount	bne	@noflame		lda	TSKclock	and	#2	bne	@big	jsl	PICput	dw	scooterframe7	rtl@big:	jsl	PICput	dw	scooterframe6	rtl** give scooter points*providepoints:	lda	seconds	ora	minutes	bne	@still	lda	winflag	bne	@done	inc	winflag		lda	#-1	sta	fade	lda	#15	sta	fadecounter	rts@still:	lda	seconds	beq	@decmin	dec	seconds	bra	@addscore@decmin:	dec	minutes	lda	#59	sta	seconds@addscore:	lda	#0	jsl	addscore@done:	rts