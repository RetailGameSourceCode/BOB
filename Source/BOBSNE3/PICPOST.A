maxsprites		equ	80	;max # of sprites to displayPICpost:	lda	#13	pha	plb;--------------------;	create sprite priority;	0=behind bob;	1=in front of bob	lda pauseflag	bne @skipbobola		lda introflag	ora enterpassword	ora staticintro	bne @lower	lda status	cmp #onworld	bne	@reghi@lower:	lda	#240	bra	@setbottom@reghi:	lda	#190@setbottom:	sta	screenbottom	@all:	ldx #1		;task counter - 0 is Bob so skip over	ldy #0	@setprior1:	lda PICadrLo,x			ora PICadrHi,x	beq @noframe		;picture associated with this task?	lda PICprior,x	beq @noframe		;not to be placed in front		txa	sta piclist,y			;make this task appear in front of bob	iny	@noframe:				inx	cpx #TSKmax	bcc @setprior1	lda #0		;bob task ID	sta piclist,y	iny			;middle task is bob's			ldx #1		;task counter - 0 is Bob so skip over				;leave Y alone	bra @setprior2	@skipbobola:	ldy #0	ldx #inven_task	@setprior2:	lda PICadrLo,x			ora PICadrHi,x	beq @noframe2		;picture associated with this task?	lda PICprior,x	bne @noframe2		;not to be placed in front		txa	sta piclist,y			;make this task appear in front of bob	iny	@noframe2:				inx	cpx #TSKmax	bcc @setprior2		lda #-1	sta piclist,y			;set EOF to -1	;-----------------------		ldy #31			;put all objects off screen...	lda #$00			;55@loop:	sta sprsizebuf,y			;sizebufptr,y	dey	bpl @loop		stz psprn			;reset pointers	stz sizebufptr	stz sizebufbit	;------------------------------------------------------drop_pics:	ldx #0	lda #<sprbuf		;current sprbufaddr	sta temp+6	lda #>sprbuf	sta temp+7		psput:	lda piclist,x		;is this an active picture?	cmp #-1	bne @getpic		jmp pszero	@getpic:	stx picpointer		;holds current offset to piclist		sta pici			;current task ID from piclist table	tax	lda PICadrLo,x		;set picture address	sta picp	lda PICadrHi,x	sta picp+1	ora picp	bne @valid_frame	;picture associated with this task?	jmp psputyz			;no picture in this task so skip drawing	@valid_frame:			;test to see if PIC is too far off to bother						;drawing it...;	lda PICxhi,x;	beq @goodx;	bmi @negx	@posx:;	lda PICxlo,x;	cmp #2;	bcc @goodx	;	jmp psputyz			;don't draw this frame		@negx;	lda PICxlo,x;	cmp #-2;	bcs @goodx	;	jmp psputyz			;don't draw this frame		@goodx:;	lda PICyhi,x;	beq @goody;	bmi @negy	@posy:;	lda PICylo,x;	cmp #2;	bcc @goody	;	jmp psputyz			;don't draw this frame		@negy;	lda PICylo,x;	cmp #-2;	bcs @goody	;	jmp psputyz			;don't draw this frame		@goody:					;---------------------------			; start reading picture data			;---------------------------	**	set DBR to bank where picture resides*		lda PICbank,x	pha	plb			;set DBR		ldy #0	;reset data table pointer		lda (picp),y	pha	and #%00111111	;mask off special char pointer bits for now	sta temp+1			;temp+1 holds max number of obj elements in this frame		pla	and #%11000000	;is this a special frame?	beq @not_special		iny			;if special frame skip next byte - used elsewhere!	@not_special:	lda PICshake,x	;anger/shake effect	beq @setshake		dec PICshake,x	;count down timer		lsr a	lsr  a	and #1	asl a	bne @setshake		lda #-2	@setshake	sta shakeoffset 	lda PICylo,x			;copy task ypos	sta postpicy	lda PICyhi,x	sta postpicyhi  					lda PICxhi,x	sta postpicxhi  			lda PICxlo,x			;copy task xpos	clc	adc shakeoffset		;**** 	sta postpicx	lda PICcolorhit,x		;is shape blinking?	beq @normalcolor		dec PICcolorhit,x	cmp #6	bne @setattr		stz PICcolorhit,x	bra @setattr		;clear blinky color@normalcolor	lda PICcolor,x		;get regular color	@setattr:	and #7			;get only color bits	asl a	ora #%00100000;	ora #%00110000	;or with priority (always fixed in front screen 0)	ora PICattr,x		;or with h and v flip bits d6,d7 and name high bit d0	sta postpicattr		;set hvflip,priority,color bits		and #niobjhflip	sta hflip	lda postpicattr	and #niobjvflip	sta vflip		iny				;advance frame data pointer	drawpic_loop:			;main loop to draw animation frame	stz temp+3			;flip 0/8/16 sub for x filp	stz temp+4			;same for y-flip			lda postpicxhi		;save off high bytes for later mods	sta tmp+5	lda postpicyhi	sta tmp+6		lda postpicattr	sta tmp+7		lda (picp),y	;get xoffset from sprite frame data		pha			;save for later instead of using  a variable	pha		and #%10000000		;test bit d7 for obj name high bit	beq @nohi_objname	@sethi_objname:	lda #%00000001	ora tmp+7	sta tmp+7		;set name high bit in attr byte	@nohi_objname:		;now check  for PICxflip attribute	lda hflip	beq @not_xflip	@xflip:	iny			;get flip mod 8/16	lda (picp),y	dey	and #%10000000	beq @add8		lda #16	bra @addup@add8:	lda #8@addup:	sta temp+3			;inverted test for pos/neg xoffset bit	pla	and  #%01000000	;test x offset hi bit (d6)	bne @positive_xoffset	;is this a pos or neg offset? 	bra @negative_xoffset@not_xflip:	pla	and  #%01000000	;test x offset hi bit (d6)	beq @positive_xoffset	;is this a pos or neg offset? 	@negative_xoffset:	;check for offscreen location		;get xoffset again	pla	and #%00111111	;strip away unused bits	clc	adc temp+3	sta tmp		lda postpicx	sec	sbc tmp	sta tmp	bcs @x_onscreen	;sprite is offscreen'	dec tmp+5@neg1:	bra @x_onscreen	@positive_xoffset:	;check for offscreen location	;get xoffset again	pla	and #%00111111	;strip away unused bits	clc	adc postpicx	bcc @pos3	inc tmp+5@pos3:	sec 	sbc temp+3	sta tmp	bcs @pos1	dec tmp+5@pos1:@x_onscreen:	lda tmp+5				;check for x offscreen	beq @xonn		;now check to see if x if just offscreen		cmp #1	beq @testoffright	cmp #-1	bne @killsprite	@testoffleft:	lda tmp	cmp #-16	bcs @xonn		iny			;kill the sprite, avoiding bra	iny	brl @noobject	@testoffright:;	lda tmp;	cmp #16;	bcc @xonn	@killsprite:	iny	iny	brl @noobject	@xonn:		;now check to see if Y offset is onscreen	iny			;increase pointer to y offset byte	lda (picp),y	;get yoffset from sprite frame data	pha	pha	and #%10000000		;mask size bit	pha	sta tmp+3				;save off 		lda vflip	;now check  for PICyflip attribute	beq @not_yflip	@yflip:	pla;;;;	and #%10000000	beq @yadd8		lda #16	bra @yaddup@yadd8:	lda #8@yaddup:	sta temp+4		;inverted test for pos/neg yoffset bit	pla	and  #%01000000	;test y offset hi bit (d6)	beq @negative_yoffset	bra @positive_yoffset	;is this a pos or neg offset? 	@not_yflip:	pla	pla	and  #%01000000	;test y offset hi bit (d6)	beq @positive_yoffset	;is this a pos or neg offset? 	@negative_yoffset:	;check for offscreen location		;get yoffset again	pla	and #%00111111	;strip away unused bits	clc	adc temp+4	sta tmp+1		lda postpicy	sec	sbc tmp+1	sta tmp+1	bcs @y_onscreen		;sprite is still onscreen'@yoffscreen:	dec tmp+6			;modify ypos hi bit	bra @y_onscreen@gonoobject:	jmp @noobject	@positive_yoffset:	;check for offscreen location	pla	and #%00111111	;strip away unused bits	sta tmp+1		lda postpicy	sec	sbc temp+4	bcs @posy1	dec tmp+6@posy1:	clc	adc tmp+1	sta tmp+1	bcc @y_onscreen		;sprite is still onscreen'		inc tmp+6			;modify ypos hi bit	@y_onscreen:		;sprite is definitely onscreen!		;now check to see if object is offscreen		iny	lda tmp+6				;on maion screen?	beq @onmainscreen	cmp #-1				;if just off top, can it still be seen?	bne  @gonoobject		lda tmp+1				;jsr off top of screen?	cmp #-16	bcs @showobj	brl @noobject	@onmainscreen:			;is on screen. to far down?	lda tmp+1	cmp screenbottom		;#190	bcs @gonoobject		;must be below status bar				;STORE OBJ DATA IN SPRITE BUFFER		;_________________________		@showobj:;	lda tmp+5				;is x too far offscreen?	;	beq @showobj2;;	cmp #-1				;only check low byte if within one screen off;	beq @offleft;	cmp #1;	beq @offright;	;	jmp @noobject			;more than one screen off so nuke sprite;	;@offright:;	lda tmp;	cmp #16;	bcc @showobj2;	iny;	jmp @noobject		;sprite too far offscreen to show it	;@offleft:;	lda tmp;	cmp #-16;	bcs @showobj2;	iny;	bra @noobject		;sprite too far offscreen to show it@showobj2:	lda (picp),y	 	phy			;save y	 	pha			;sta tempsprbuf+2	;,x		;set object name lo byte	*now copy temp sprbuf data into sprbuf		ldx pici	lda PICbehind1,x	sta tempd+6		ldy #0	lda tmp			;xpos			sta (temp+6),y	iny	lda tmp+1			;ypos		sta (temp+6),y	iny	pla				;name	sta (temp+6),y	iny	lda tmp+7			;attr			ora tempd+6		;with PICb	sta (temp+6),y			ldy psprn	ldx pici		cpx #0	beq @setforbob		lda PICscroll,x	sta spritetask,y		;this sets byte to 0 no matter what happens next	beq @nosync		;if non-scrolling, leave = 0		txa				;save current task #	sta spritetask,y		;set sprite task byte to indicate which task dropped this	bra @nosync	@setforbob:	lda #99	sta spritetask,y	@nosync:	;	lda PICmoveh,x;	sta spritemoveh,y	lda PICmovev,x	sta spritemovev,y			lda temp+6			;advance sprite pointer	clc	adc #4	sta temp+6	bcc @nextpoint		inc temp+7	@nextpoint:** get size large/small of sprite*;	lda tmp+3		;large or small?;	beq @nextentry	lda #13	pha	plb			;set DBR bank 0 for reading bit tables	ldx sizebufptr	;size buffer byte pointer	lda sizebufbit	;size buffer bit combination	and #3	tay		lda tmp+3		;large or small?	beq @nextentry	lda setlarge,y	;set appropriate bit	ora sprsizebuf,x	sta sprsizebuf,x	;save new size	@nextentry:	lda tmp+5		;x high byte	beq @donesmall		lda setoffscreen,y	;set appropriate bit	ora sprsizebuf,x	sta sprsizebuf,x	;save new size@donesmall:	inc sizebufbit	;next 2 bit combo	lda sizebufbit	and #3	bne @samebyte	inc sizebufptr	;next byte if 4 entries done	@samebyte:	ldx pici	lda PICbank,x	pha	plb		ply** carry on..*	ldx psprn	inx		cpx #maxsprites			;at max # of sprites?	bcc @notmax		stx maxdisplayed			;ran out of room.	bra lastp				@notmax:	stx psprn	@noobject:	;jmp here if ignoring current sprite (offscreen check)psputx1:	dec temp+1	beq psputyz		iny	brl drawpic_loop	psputyz:	ldx picpointer			;go through all tasks...	inx	cpx #TSKmax	bcs pszero		jmp psput			;next picture ; Clear remaining sprite bufferspszero:		ldx psprn	stx maxdisplayed		;what was actual number of sprites displayed (for movepics)		ldy #1pszloop	lda #240			;set obj ypos offscreen	sta (temp+6),y		stz spritetask,x		;clr sprite task pointer 		lda temp+6			;advance sprite pointer	clc	adc #4	sta temp+6	bcc @clearoff		inc temp+7	@clearoff:	inx	cpx #maxsprites+1		;test to speed up picpost	bcc pszloop		;test	lastp:			lda #0	pha	plb	rtl	;=============================================================================; Associate picture address following call with current task; 0 = nonePICput:	jsr getadr13	pla	sta tmp	pla 	sta tmp+1; Picture address is in tmpPICput2:	lda tmp	sta PICadrLo,x	lda tmp+1	sta PICadrHi,x;	lda 3,s			;get bank of picture calling PICput - 3rd byte in stack;	sta PICbank,x		rtl** oam size bit possibilites..*setlarge:	dc.b %00000010	dc.b %00001000	dc.b %00100000	dc.b %10000000	setoffscreen:	dc.b %00000001	dc.b %00000100	dc.b %00010000	dc.b %01000000		;-----------------------------------------------------------------------	;-------------+-----------------------------+---------------------------	;--------------LET ME OUT OF THIS MEZUZZAH (SIC) BOX------------------------------	;-------------+-----------------------------+---------------------------	;-----------------------------------------------------------------------	movepics:			;stupid picpost to save time every 1/30 second	stz tmp+4	stz tmp+1	lda enemy_leftscroll        beq @mright		sec			;negate for left	sbc #1	eor #255	sta tmp+4         bra @mup	 @mright	lda enemy_rightscroll	sta tmp+4	@mup	lda enemy_upscroll        beq @mdown		sec			;negate for left	sbc #1	eor #255	sta tmp+1	        bra @mdone	@mdown:	lda enemy_downscroll	sta tmp+1	 @mdone:		;-------------------------------------------------	ldy #0	ldx #0	@move1:        lda spritetask,x        cmp #99        beq @bobtest                cmp #0        bne @moveobj                brl @fuckujb              @bobtest:;    	cmp #0		;if bob...;	bne @notnice		lda bobmd	beq @notnice@nice:	lda  lookbelow	;and doing scroll adjust	beq @notnice		stz spritemovev,x        lda     tmp+1        sta     tmp+3	brl @posy	;keep y-smooth	@notnice:        brl @fuckujb          ;must be a non mover so fuck off and die        @moveobj:	        lda     tmp+4         sta     tmp+2        lda     tmp+1        sta     tmp+3	lda tmp+4	bne @noadjust1	      brl @posy		;nothing to move....        @noadjust1:        lda     tmp+2           ; Test sign of what we're adding        bpl     @posx        eor     #-1             ; If negative negate it and subtract it        inc     a        sta     tmp+2        lda     sprbuf+0,y        sec        sbc     tmp+2        bcc     @highbit        bra     @diepicdienot@highbit:        pha                             ; Save low byte for later.        phy        tya        lsr     a        lsr     a                      ; Now each represents each sprite        pha        lsr     a        lsr     a                       ; Divide by 4 for high index.        and     #$fe        pha                             ; Push destination index.        lda     2,s                     ; Get which sprite        and     #7        tay        SET16A        lda     #1        cpy     #0        beq     @zero@shiftlp:        asl     a        asl     a        dey        bne     @shiftlp@zero:        ply                             ; Get destination index        ora     sprbuf+512,y        sta     sprbuf+512,y            ; Store it        SET8A        pla                             ; Pull off which sprite it is.        ply                             ; Get old index        pla                             ; Get low HOFFSET        bra     @diepicdienot@posx:        lda sprbuf+0,y        clc        adc tmp+2        bcc @diepicdienot		@diepicdie:        lda     #225        sta    sprbuf+1,y        bra    @fuckujb@diepicdienot:          sta sprbuf+0,y        ; Now do Y	---------------------------------@posy:	lda tmp+3	clc        adc spritemovev,x	beq @fuckujb		;no vertical value so skip move        lda sprbuf+1,y        clc        adc tmp+3	clc        adc spritemovev,x 	sta temp+3; now check sprite position        phy        ldy     spritetask,x	lda 	PICyhi,y	cmp #0	beq @offtop1  			;definately off top	cmp #1	beq @offtop2     	bra @offtop1a			;must be -1@offtop1:	   	lda PICylo,y	bmi @offtop2		;top or bottom half main screen?@offtop1a:	lda temp+3	cmp #200	bcc @finalmove	;visible area. ok.; now sure PIC x,y is going off top... what now?	cmp #-32	bcc @gotodie   ;must be about to wrap around. kill it	bra @finalmove		;otherwise ok.@offtop2:	; this guy is coming up from bottom	lda temp+3	cmp #-32	bcs @gotodie	;must be trying to wrap to top again. kill	bra @finalmove@gotodie:	ply        lda     #224        sta    sprbuf+1,y        bra    @fuckujb@finalmove:	lda temp+3	ply	sta	sprbuf+1,y	@fuckujb:                inx        cpx maxdisplayed	bcc @more	jmp endmovepics	@more:        iny        iny        iny        iny        beq     @jumpit        jmp     @move1@jumpit:;        bne @move1relabs:		;---**************---------*********--        ldy #0@move1:        lda spritetask,x        bne @moveobj                jmp @fuckujb          ;must be a non mover so fuck off and die        @moveobj:        lda     tmp+4        sta     tmp+2        lda     tmp+1        sta     tmp+3	lda tmp+4	bne @noadjust1	      brl @posy		;nothing to move....        @noadjust1:        lda     tmp+2           ; Test sign of what we're adding        bpl     @posx        eor     #-1             ; If negative negate it and subtract it        inc     a        sta     tmp+2        lda     sprbuf+0+256,y        sec        sbc     tmp+2        bcc     @highbit        bra     @diepicdienot@highbit:        pha                             ; Save low byte for later.        phy        tya        lsr     a        lsr     a                      ; Now each represents each sprite        pha        lsr     a        lsr     a                       ; Divide by 4 for high index.        and     #$fe        pha                             ; Push destination index.        lda     2,s                     ; Get which sprite        and     #7        tay        SET16A        lda     #1        cpy     #0        beq     @zero@shiftlp:        asl     a        asl     a        dey        bne     @shiftlp@zero:        ply                             ; Get destination index        ora     sprbuf+512+16,y        sta     sprbuf+512+16,y            ; Store it        SET8A        pla                             ; Pull off which sprite it is.        ply                             ; Get old index        pla                             ; Get low HOFFSET        bra     @diepicdienot@posx:        lda sprbuf+0+256,y        clc        adc tmp+2        bcc @diepicdienot        	@diepicdie:        lda     #225        sta    sprbuf+1+256,y        bra    @fuckujb@diepicdienot:         sta sprbuf+0+256,y        ; Now do Y	---------------------------------@posy:	lda tmp+3	clc        adc spritemovev,x	beq @fuckujb		;no vertical value so skip move	        lda sprbuf+1+256,y        clc        adc tmp+3	clc        adc spritemovev,x        sta temp+3; now check sprite position        phy        ldy     spritetask,x	lda 	PICyhi,y	cmp #0	beq @offtop1  			;definately off top	cmp #1	beq @offtop2     	bra @offtop1a			;must be -1@offtop1:	   	lda PICylo,y	bmi @offtop2		;top or bottom half main screen?@offtop1a:	lda temp+3	cmp #200	bcc @finalmove	;visible area. ok.; now sure PIC x,y is going off top... what now?	cmp #-32	bcc @gotodie   ;must be about to wrap around. kill it	bra @finalmove		;otherwise ok.@offtop2:	; this guy is coming up from bottom	lda temp+3	cmp #-32	bcs @gotodie	;must be trying to wrap to top again. kill	bra @finalmove@gotodie:	ply        lda     #224        sta    sprbuf+1+256,y        bra    @fuckujb@finalmove:	lda temp+3	ply	sta	sprbuf+1+256,y	@fuckujb:                inx        cpx maxdisplayed	bcs endmovepics        iny        iny        iny        iny        beq     @jumpit        jmp     @move1        @jumpit:endmovepics:	rtl;---------------------------------------------------------------------------- ****		clear undrawn sprites in sprite buffer before game starts;-----------------------------------------------------clearspriteslong:	jsr clearlastsprites	rtl		clearlastsprites:	lda #<sprbuf		;current sprbufaddr	sta temp+6	lda #>sprbuf	sta temp+7		@pszero:		ldx #0@pszloop	lda #0			;set obj ypos offscreen	tay	sta (temp+6),y		iny	lda #240	sta (temp+6),y	stz spritetask,x		;set sprite task pointer to a too high value;	stz spritemoveh,x;	stz spritemovev,x		lda temp+6			;advance sprite pointer	clc	adc #4	sta temp+6	bcc @clearoff		inc temp+7	@clearoff:	inx	bpl @pszloop		rts		;=============================================================================getadr13:			;get address off stack	pla	sta tmp	pla	sta tmp+1		;return address to caller	pla			;points to address location - 1	sta tmp+2	clc	adc #2	tay	pla	sta tmp+3	adc #0	pha	tya	pha			;push back corrected return address; Push address onto stack	ldy #2	lda (tmp+2),y		;hi	pha	dey	lda (tmp+2),y		;lo	pha	lda tmp+1		;return to caller	pha	lda tmp	pha	rts	