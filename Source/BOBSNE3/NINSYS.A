; 					SNES NINSYS;	FUNCTION: CONTROLS MOST SYSTEM STUFF; 	COMMENCED AUGUST 27, 1991; debug	equ	0				; 0=normal state, 1=debug on			; Status flag definitonsTSKactive	equ $80			;set if task is aliveTSKwaiting	equ $40niobjhflip	equ	%01000000	;hflip bitniobjvflip	equ	%10000000	;vlfip bit ;===========================================================================; summary of picture related routines;-------------------;	 PICput			;associate picture address with a task;	 PICput2			;picture address is in TMP;	;	 PICxset			;set Xpos from A (low); hi = 0;	 PICxset2		;set Xpos from Y (low) & A (high);	 PICxadd			;add A to current xpos;	 PICxdec			;decrement Xpos;	 PICxinc			;increment Xpos;	 PICxsub			;sub A from current xpos;	 PICxyset		;set x and y lo, clear hi;	 PICxflip			;set xflip attribute;	;	 PICyflip			;set y flip attribute;	 PICyadd			;add A to current ypos;	 PICyset			;set Ypos from A (low); hi = 0;	 PICyset2		;set Ypos from Y (low) & A (high);	 PICydec			;decrement Ypos;	 PICyinc			;increment Ypos;	 PICysub			;sub A from current ypos;; Global Task handler routines; 	TSKcancel		;kill task; 	TSKhandler	;main driver; 	TSKinit			;reset all tasks; 	TSKschedule	;schedule a new task for taskhandler ; 	TSKschedule2	;schedule task with register contents; 	TSKsuspend		;pause task and resume from here next cycle; 	TSKvblank			;install vblank task; 	TSKwait			;wait A ticks before resuming task from here;=============================================================================; T S K    Procedures;=============================================================================; Cancel task X	TSKcancel:	lda #0			;zero the flags	sta TSKflags,x	jsr cleartaskmap		stz PICadrLo,x	stz PICadrHi,x		;clear PIC address		rtl;=============================================================================;Task Handler;----------------TSKhandler:	lda 	pauseflag			;processing "pause"		beq 	@likeregular	** 	#1 - fade out game screen*	cmp	#1	bne	@try2	jsr	showinventory		;build inventory screen	ldx	#inven_task	jsr	TSKhan1	inc	pauseflag	@wait:	rts** 	#2 - screen built show it*@try2:	cmp	#2	bne	@try3	ldx	#inven_task		;only run inventory task	jsr	TSKhan1	lda	#4	sta	invengoto	inc	pauseflag	rts	** 	#3 - wait for fade to complete, then process stick*@try3:	cmp	#3	bne	@try4	ldx	#inven_task		;only run inventory task	jmp	TSKhan1** 	#4 - wait for inventory to fade out, then rebuild game screen*@try4:	cmp	#4	bne	@try5	jsr	removeinventory		;rebuild game screen	inc	pauseflag;	lda	#0;	jsr	TSKhan1@wait3:	rts	**	#5 - wait for fade in to complete, then end pause*@try5:	stz	pauseflag			;replay the game;	lda	#0;	jsr	TSKhan1	lda	#4	sta	invenreturn	@wait4:	rts	** game not paused - play as regular*@likeregular:	inc taskalt	lda taskalt	and #1	sta taskalt			;optimizer flag	 ; Activate each active task	ldx #0TSKhan1:		stz PICmoveh,x	stz PICmovev,x		;clear "stupid" picscroll values every cycle	stz spritemoveh,x	stz spritemovev,x		lda TSKflags,x	bpl TSKhan2			;inactive	sta tmp+5							;preserve flags;	lda status			;????? chris generate bad bug!!!!!!;	cmp #rideship		;PICxhi is fucked@$@#$@@@!!;	beq	@no_sync		lda PICscroll,x		;sync task with scrolling?	beq @no_sync		jsr sync_with_scrolling	;move the task		lda PICscroll,x	cmp #1	beq @no_sync			;not to be altered		jsl offscreen	@no_sync:; Handle wait field	lda TSKwaitLo,x	beq TSKhanc			;nothing to do if zero	sec	sbc #1	sta TSKwaitLo,x		;	beq TSKhannw			;1 -> 0; clear wait flag;; Wait is not zero.  See if task is waiting.	lda tmp+5	and #TSKwaiting	bne TSKhan2			;is waiting, don't callTSKhannw:	lda #TSKactive			;clear all flags but active	sta TSKflags,xTSKhanc:	stx TSKcurrent				lda TSKadrLo,x	sta tmp	lda TSKadrHi,x	sta tmp+1	lda TSKbank,x	sta tmp+2	pha	plb					;set data bank to upcoming prg bank	jsl taskjump		ldx TSKcurrentTSKhan2:	lda alternate	and #1	bne @half@alltasks:	inx	cpx #TSKmax+1	bcc TSKhan1		;loop while more tasks; Now post all active pictures for next cycle	inc TSKclock		;bump system clock@half:	rtstaskjump:			;execute task	jml (tmp)	;=============================================================================; Cancels all tasks (required for once only intialization)task_typetable1:		;BORGS - table of task type ranges			;1st byte is start within table, 2nd byte is max # of entries			;for that type of task	dc.b	0,2	;bob				dc.b	2,15		;borgs/boxes	dc.b	18,3		;remotes				dc.b	21,3		;weapons	dc.b	24,4		;platforms	dc.b	29,3		;items	dc.b	32,3		;inventorytype_bob	equ	0type_enemy	equ	1type_remote	equ	2type_weapon	equ	3type_walk	equ	4type_item	equ	5type_inven	equ	6inven_task	equ	32type_badbullet	equ	8type_wall		equ	33		;crushingtype_elevator	equ 88		;elevators/platformstype_platform	equ 89		;horiz platformtype_bubble		equ	90		;ultra force bubbletype_trapdoor	equ 91		;trap doortype_platform2	equ	92		;drop platformtype_crumbler	equ	93		;lava crumblerTSKinit2:	ldx #TSKmax	lda #0@TSKini1	sta TSKflags,x	sta PICadrHi,x	sta PICadrLo,x	dex	cpx #0	bne @TSKini1	rts		TSKinit:	ldx #TSKmax	lda #0TSKini1	sta TSKflags,x	sta PICadrHi,x	sta PICadrLo,x	dex	bpl TSKini1	rtl;=============================================================================; Schedule task whose address follows the call; Returns X = -1 if failure, otherwise returns task idTSKschedule	sta tasktype		;save off task type for now	lda 3,s		;get prog bank resister - save for now	sta tempbank			jsr getadr		;get address under call onto stack	pla	sta tmp	pla	sta tmp+1		phb		bra TSKschedule3b	TSKschedule2; Search for inactive task	lda 3,s		;get prog bank resister - save for now	sta tempbank	phb		bra TSKschedule3b	TSKschedule3	phbTSKschedule3b	lda	#0	pha	plb		lda tasktype	asl a			;double to create pointer for type table	tay	lda (tasktable),y	tax			;X holds start of type range within task table	cpx #TSKmax	bcs TSKfail		;bug check - don't continue if X out of max TASK range!	iny	lda (tasktable),y	sta tmp+2		; max # of tasks in that type range		ldy #0		;counter of available task slots	TSKsch1		lda TSKflags,x	bpl TSKsch2			;inactive	iny	cpy tmp+2		;out of available tasks yet?	bcs @failed		;yes	inx			;else keep looking for new tasks	cpx #TSKmax	bcc TSKsch1	;out of tasks.@failed:				;no room for this taskTSKfail:	txa	ldx TSKcurrent			;reload current task id	clc				;bit = 0 then failed	plb	rtl			;failedTSKsch2:	lda #TSKactive			;activate	sta TSKflags,x	lda tmp	sta TSKadrLo,x	lda tmp+1	sta TSKadrHi,x	lda tempbank	sta TSKbank,x			;set program bank 		stz	TSKwaitLo,x		;not waiting	lda tasktype				;	sta PICtype,x		lda bossbehind	bne @other	lda #%00100000		;clear all task & pic variables 	bne @setbehind@other:	lda #%00010000@setbehind:	sta PICbehind1,x	lda #0	sta PICattr,x;	lda #0	sta PICadrLo,x	sta PICadrHi,x				sta PICcolor,x				sta PICxhi,x					sta PICyhi,x					sta PICxlo,x	sta PICylo,x	sta PIClocked,x		sta PICflag,x			;clear general use flags	sta PICanim,x	sta PICdir,x	sta PICcount,x	sta PICthingy,x	sta PIClogic,x	sta PICstatus,x	sta PICcolor,x	sta PICscroll,x	sta PICcount2,x	sta PICbank,x	sta PICmaplo,x			;zero out map start	sta PICmaphi,x	sta PICvomit,x	sta PICsize,x	sta PICdirv,x	sta PIChealth,x	sta PICtemp1,x	sta PICtemp2,x	sta PICyoffset,x	sta PICmoveh,x	sta PICmovev,x	sta PICprior,x	sta PICcolorhit,x	sta PIChit,x	sta PICcollide,x	sta PICshake,x		txa	ldx TSKcurrent			;reload current task id	sec				;bit = 1 then success	plb	rtl				;success;=============================================================================; Suspend task at current position; Stack holds.b call to Suspend, plus initial call to taskTSKsuspend:	ldx TSKcurrent	pla	clc	adc #1			;correct screwy JSR address	sta TSKadrLo,x	pla	adc #0	sta TSKadrHi,x	pla				;fuck the program bank	rtl			;return to task handler;=============================================================================; Wait A ticks before resumingTSKwait:	ldx TSKcurrent	sta TSKwaitLo,x	lda #TSKactive+TSKwaiting	sta TSKflags,x	jmp TSKsuspend	;=============================================================================getadr:			;get address off stack	pla	sta tmp	pla	sta tmp+1		;return address to caller	pla			;points to address location - 1	sta tmp+2	clc	adc #2	tay	pla	sta tmp+3	adc #0	pha	tya	pha			;push back corrected return address; Push address onto stack	ldy #2	lda (tmp+2),y		;hi	pha	dey	lda (tmp+2),y		;lo	pha	lda tmp+1		;return to caller	pha	lda tmp	pha	rts;--------------------------------------------------------------;===========================================================================;=============================================================================PICbehind:		;set x flip flag;	lda PICbehind1,x	lda #%00110000	sta PICbehind1,x	rtl;===========================================================================;=============================================================================PICxflip:		;set x flip flag	lda PICattr,x	ora #niobjhflip	sta PICattr,x	rtl;=============================================================================PICyflip:		;set y flip flag	lda PICattr,x	ora #niobjvflip	sta PICattr,x	rtl;=============================================================================PICxunflip:		;clear x flip flag	lda PICattr,x	and #%10111111	sta PICattr,x	rtl;=============================================================================PICyunflip:		;clear y flip flag	lda PICattr,x	and #%01111111	sta PICattr,x	rtl;=============================================================================PICxdec:			;decrement x	lda #1PICxsub:			;subtract A from Xpos	sta tmp	lda PICxlo,x	sec	sbc tmp	sta PICxlo,x	bcs PICxsub2	dec PICxhi,xPICxsub2:	rtl;=============================================================================PICxinc:		;incrment x	lda #1PICxadd:	sta tmp	lda tmp	bmi @doneg		;negative value	lda PICxlo,x	clc	adc tmp	sta PICxlo,x	bcc @PICxadd2		inc PICxhi,x	@PICxadd2:	rtl@doneg:	eor #%11111111		;make negative	clc	adc #1	jmp PICxsub		;go and subtract, not add, IDIOT!;=============================================================================PICxset:		;set x from A (low)	tay	lda #0PICxset2:			;set x from Y (low) & A (hi)	sta PICxhi,x	tya	sta PICxlo,x	rtl	;=============================================================================PICxyset:		;set Xpos=A & Ypos=Y, hi = 0	sty tmp	jsl PICxset	lda tmp	jmp PICyset;=============================================================================PICydec:			;decrement Ypos	lda #1PICysub:	sta tmp	lda PICylo,x	sec	sbc tmp	sta PICylo,x	bcs @a1	dec PICyhi,x@a1:		rtl;=============================================================================PICyinc:	;increment Ypos	lda #1PICyadd:	sta tmp	lda tmp	bmi @doneg		;negative value	clc	adc PICylo,x	sta PICylo,x	bcc @a1	inc PICyhi,x@a1:		rtl	@doneg:	eor #%11111111		;make negative	clc	adc #1	jmp PICysub		;go and subtract, not add, IDIOT!;=============================================================================PICyset:		;set Ypos from A (low)	tay	lda #0PICyset2:		;set Y from Y (low) and A (hi)	sta PICyhi,x	tya	sta PICylo,x	rtl	**		SYNCHRONIZE TASK WITH SCROLLING BACKGROUNDS*		THIS WILL AUTOMATICALLY HAPPEN IF PICscroll <>0sync_with_scrolling		proc	lda enemy_leftscroll	beq @tryright		jsl	PICxsub		;move task	bra @tryup	@tryright	lda enemy_rightscroll	beq @tryup		jsl PICxadd			;move task	@tryup	lda enemy_upscroll	beq @trydown		jsl PICysub			;move task	rts	@trydown	lda enemy_downscroll	beq @nosync		jsl PICyadd			;move task	@nosync:	rts	bfbank	equ	5		;bank for special bob frames and small framessetbigframe		proc; initialize the current big frame base address	sta tmp	sty tmp+1		phb				;set bob frame bank	lda #bfbank	pha	plb		ldy #0	lda (tmp),y	and #%00111111		;mask in max element value	sta bigframe	;1st byte always holds number of elements in frame	tax			;element counter	lda (tmp),y	and #%01000000	;this bit holds hi byte for charcter pointer	sta specaddr+1		iny	lda (tmp),y		;2nd byte holds low byte pointer within character data	sta specaddr			iny	@copytobig:	lda (tmp),y		;copy one block of frame data (x,y,name)	jsr adjust_bigxoffset	sta bigframe-1,y	iny	lda (tmp),y	jsr adjust_bigyoffset	sta bigframe-1,y	iny	lda (tmp),y	sta bigframe-1,y	iny	dex	bne @copytobig		;copies whole frame yet?		dey	sty endbigframe		;this is the current end of frame pointer		inc bigoffset_pointer	;inc pointer for bigframe offsets		plb				;restore bank		rts				;now frame resides in ram. 		**		append to current bigframe*addbigframe	proc	sta tmpx	sty tmpx+1		phb				;set bob frame bank	lda #bfbank	pha	plb	jsr update_bigframe_offset	;get current bigframe offsets		ldx #0	lda (tmpx,x)	and #%00111111	sta tmp+2		;number of new elements to ADD to bigframe	lda bigframe+0	;now frame is bigger than  before	clc	adc tmp+2	sta bigframe+0	lda (tmpx,x)	and #%01000000	;this bit holds hi byte for charcter pointer	sta specaddr+1		jsr screwoff			lda (tmpx,x)	;2nd byte holds low byte pointer within character data	sta specaddr		jsr screwoff		ldy endbigframe	;destination pointer	@addtobig:	lda (tmpx,x	)	;copy one block of frame data (x,y,name)	jsr adjust_bigxoffset	sta  bigframe,y	iny	jsr screwoff		lda (tmpx,x)	jsr adjust_bigyoffset	sta bigframe,y	iny	jsr screwoff		lda (tmpx,x)	sta bigframe,y	jsr screwoff		iny	dec tmp+2	bne @addtobig		;added whole frame yet?	sty endbigframe		;new end of frame pointer		inc bigoffset_pointer	;inc pointer to bigframe offset data		plb 		rts				;new frame resides in ram. 		screwoff	proc	lda tmpx	clc	adc #1	sta tmpx	bcc @fuckfuck	inc tmpx+1@fuckfuck	rts**	set offset from centre point of big frame 	set_bigframe_offset	proc	sta temp+4			;A & Y hold addr of bigframe offset table	sty temp+5				stz bigoffset_pointer	;reset table pointer to 0		update_bigframe_offset	proc	lda bigoffset_pointer	asl a				;get pointer x 2 for table of bigframe offsets	tay				;y holds offset within table (0,2,4,6...)		lda (temp+4),y	sta bigxoffset		;new xoffset	iny	lda (temp+4),y	sta bigyoffset		;new yoffset		rts	adjust_bigxoffset:	phx	phy		sta temp	and #%00111111	sta temp+2			;make frame xoffset abosolute		lda temp			;now make into pos/neg byte	and #%01000000	beq @pos_offset		lda temp+2	sec	sbc temp+2	sec	sbc temp+2			;now temp+2 is negative	sta temp+2	@pos_offset:	lda bigxoffset		;make new xoffset absolute	and #%00111111	sta temp+1			lda bigxoffset	and #%01000000	beq @addx	@subx:	lda temp+2	sec	sbc temp+1	bra @finalize_offset	@addx:	lda temp+2	clc	adc temp+1	@finalize_offset:	sta temp+3	bpl @done		;is xoffset positive then done		;new offset is negative so make it fit with picpost format		sec	sbc #1	eor #255	and #%00111111		;invert value (to absolute positive)	ora #%01000000		;set negative bit	sta temp+3	@done:	lda temp	and #%10000000	;get original name bit	ora temp+3			;mix it with new offset		ply	plx		rts			;really done...		adjust_bigyoffset:	phx	phy		sta temp	and #%00111111	sta temp+2			;make frame xoffset abosolute		lda temp			;now make into pos/neg byte	and #%01000000	beq @pos_offset		lda temp+2	sec	sbc temp+2	sec	sbc temp+2			;now temp+2 is negative	sta temp+2	@pos_offset:	lda bigyoffset		;make new xoffset absolute	and #%00111111	sta temp+1			lda bigyoffset	and #%01000000	beq @addy	@suby:	lda temp+2	sec	sbc temp+1	bra @finalize_offset	@addy:	lda temp+2	clc	adc temp+1	@finalize_offset:	sta temp+3	bpl @done		;is xoffset positive then done		;new offset is negative so make it fit with picpost format		sec	sbc #1	eor #255	and #%00111111		;invert value (to absolute positive)	ora #%01000000		;set negative bit	sta temp+3	@done:	lda temp	and #%10000000	;get original name bit	ora temp+3			;mix it with new offset		ply	plx		rts			;really done...**		calculate address of current special frame character data for DMA*		use later on...*calc_spec:	sta temp			;save off base address of data table	sty temp+1	;	phb				;set bob frame bank;;	lda #bfbank;	pha;	plb	lda specaddr+1	;now adjust hi bit properly 	beq @setlow		lda #1	sta specaddr+1	@setlow:			;now adjust low byte *32 to get first addr within table	lda specaddr	clc	asl a	rol specaddr+1	asl a				rol specaddr+1	asl a				rol specaddr+1	asl a				rol specaddr+1	asl a				rol specaddr+1	sta specaddr		lda specaddr+1			;now add base offset into char data	clc	adc temp+1	sta specaddr+1		lda specaddr	clc	adc temp	sta specaddr	bcc @setspec		inc specaddr+1	@setspec:;	plb		lda specaddr			;holds adjusted final addr into data	ldy specaddr+1				rts**************************************************	*	offscreen check - see if task is offscreen and cancel if too far off*maxoffscreenh	equ		64	;100		;max pixels offscreen left or rightmaxoffscreenv	equ		64	;100		;max pixels offscreen top or bottomoffscreen	proc	lda PICxhi,x			;check x hi	beq @vcheck		;x is not onscreen so check low byte		bpl @offright	@offleft:	lda PICxlo,x	cmp #-maxoffscreenh	bcc @killtask		;too far to left so kill		bra @vcheck			;ok. now try vertical	@offright:	lda PICxlo,x	cmp #maxoffscreenh	bcs @killtask		;too far to right so kill			@vcheck			;try vertical	lda PICyhi,x	beq @done		;y is not onscreen so check low byte		bpl @offbottom	@offtop:	lda PICylo,x	cmp #-maxoffscreenv	bcc @killtask		;too far above so kill		bra @done		;ok. now try vertical	@offbottom:	lda PICylo,x	cmp #maxoffscreenv	bcs @killtask		;too far to right so kill	@done	rtl@killtask:			;task is offscreen so kill it	lda PICmaplo,x		;get addr within task map	sta tmp	lda PICmaphi,x	sta tmp+1	ora tmp	beq @noaddr			;but skip update if addr is 0		phb					;save current data bank	lda #$7e			;set bank to task map data	pha	plb	ldy #0	lda PICscroll,x	cmp #3				;type 3 = permanent removal 	beq @removeit	@stunit:					;type 2 			lda (tmp),y	and #%01111111		;clear task active bit for future generation	sta (tmp),y	bra @doneit		@removeit:	lda #0				;type 3 permanent removal of task from task map	sta (tmp),y	@doneit:	plb					;reset current data bank	@noaddr	jsl TSKcancel			rtl					;kill task	**  sync tasks with scrolling background during PICpost cycle*syncsprites:	ldx #0@s1	lda TSKflags,x	bpl @no_sync			;inactive	lda PICscroll,x		;sync task with scrolling?	beq @no_sync		jsr sync_with_scrolling	;move the task		lda PICscroll,x	cmp #1	beq @no_sync			;not to be altered		jsl offscreen	@no_sync:	inx	cpx #TSKmax+1	bcc @s1		;loop while more tasks	rts	**	COPY TASK - COPY PART OR MOST OF ONE TASK TO ANOTHER*copytask2:			;copy most of the task	tay		lda PICtemp1,x	sta PICtemp1,y	lda PIClogic,x	sta PIClogic,y		lda PICstatus,x	sta PICstatus,y		lda PICscroll,x	sta PICscroll,y		lda PICattr,x	sta PICattr,y		tya	copytask:			;copy x and y	tay	lda TSKbank,x	sta TSKbank,y			lda	PICxhi,x	sta	PICxhi,y		lda	PICyhi,x	sta	PICyhi,y	lda	PICdir,x	sta	PICdir,y		lda	PICxlo,x	sta	PICxlo,y		lda	PICylo,x	sta	PICylo,y		lda PICdir,x	sta PICdir,y		ldx	TSKcurrent		;restore X only		rtlcleartaskmap:	lda PICmaplo,x		;get addr within task map	sta tmp	lda PICmaphi,x	sta tmp+1	ora tmp	beq @noaddr			;but skip update if addr is 0		phb					;save current data bank	lda #$7e			;set bank to task map data	pha	plb	ldy #0	lda PICscroll,x	cmp #3				;type 3 = permanent removal 	beq @removeit	@stunit:					;type 2 			lda (tmp),y	and #%01111111		;clear task active bit for future generation	sta (tmp),y	bra @doneit		@removeit:	lda #0				;type 3 permanent removal of task from task map	sta (tmp),y	@doneit:	plb					;reset current data bank	@noaddr	rts					