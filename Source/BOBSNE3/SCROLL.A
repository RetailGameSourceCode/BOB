;;		MULTI DIRECTIONAL SCROLL ROUTINES FOR SNES;	---------------------------------------------------;**	scroll routine specific equates*bufferarea		equ	512mapsize			equ	8192*2		;size of each map zone (80x80 max)scrollmap		equ	$7e3000taskmap			equ	scrollmap+mapsize+bufferareaclearscroll2:	stz		enemy_leftscroll	stz		enemy_rightscroll	stz		enemy_upscroll	stz		enemy_downscrollclearscroll:		stz 	scroll_up	stz 	scroll_down	stz 	scroll_right	stz 	scroll_left	rtsclear_halfscroll		;setup halfscroll data	lda Hpos	sta halfhpos	lda Vpos	sta halfvpos	stz halfscroll_left	stz halfscroll_right	stz halfscroll_up	stz halfscroll_down	rts		** update blocks, map pointers and then fill screen with new scrolling data*mainscroll:				;this is the main control loop for scrolling				lda	#<screenram		;screen ram destination	clc	sta	put				lda	#>screenram	sta	put+1			;determine which side of screen to draw to				@setset:	lda scroll_down	bne @settop		lda scroll_up	bne @setbottom		bra @setset2		;keep same offset if no other changes made	@setbottom:	lda #-8	sta topoffset	bra @setset2	@settop:	stz topoffset@setset2:	lda	lockscreen	;nomainscroll	bne	@goskip	lda	status	cmp	#rideship	bne @notskip		@goskip:	brl @skip	@notskip:	lda scroll_left	ora scroll_right	ora changeflag;	beq @skiphscroll		;speed	lda startblowing		;about to be windblown?	beq @notstarting		dec startblowing		;slow dec for mr. potato	;	lda #1;	sta changeflag	;	lda blowdir;	dec a			;make 1 or 2 into 0 or 1;	eor #1			;invert for scroll logic;	sta lsdir	;this is correct new dir for this cycle	@notstarting:		lda hpos	sta hposc		lda changeflag	beq @sh1		lda hpos_old	sta hposc	@sh1:	jsr setaddrh			;set screen addr for horizontal scrolling line		lda blockcounth	sta blockcounthc		;put new blockcount into current blockcount	@skiphscroll	lda scroll_up	ora scroll_down	beq @skipvscroll			jsr setaddrv			;set screen addr for vetical scrolling line	jsr fillbufferv			;fill vertical buffer		jsr dumpbufferv	@skipvscroll:	lda map	sta map_current	lda map+1	sta map_current+1	lda blockcountv	sta blockcountvc	lda vpos	sta vposc		lda changeflag	beq @sameway		;not a dir change cycle		lda map_old	sta map_current	lda map_old+1	sta map_current+1		lda blockcounth_old		;changed dir. get previous blockcount 	sta blockcounthc		lda vpos_old	sta vposc	lda blockcountv_old	sta blockcountvc	@sameway:	lda scroll_left	ora scroll_right	ora changeflag;	beq @skiphscroll2		jsr fillbufferh			;fill horiz. buffer	jsr dumpbufferh@skiphscroll2	@skip:	lda hpos	sta hpos_old	;make current hpos "old" for next cycle		lda blockcounth	sta blockcounth_old		lda map	sta map_old	lda map+1	sta map_old+1	lda vpos	sta vpos_old	lda blockcountv	sta blockcountv_old		stz changeflag				lda gamestart	beq @settingup		;must be called from initscroll		lda scroll_left	     	;copy scroll values so other objects can move in sync	sta enemy_leftscroll	;with the background	lda scroll_right	sta enemy_rightscroll	lda scroll_up	sta enemy_upscroll	lda scroll_down	sta enemy_downscroll	lda scroll_left	beq @ne1	jsl generate_right_enemies@ne1:	lda scroll_right	beq @ne2	jsl generate_left_enemies@ne2:	lda scroll_up	beq @ne3	jsl generate_bottom_enemies@ne3:	lda scroll_down	beq @ne4	jsl generate_top_enemies@ne4:	@settingup:	ldx 	TSKcurrent				;restore X in case it got nuked elsewhere		jmp	clearscroll			;=====================================================================; LEFTSCROLL - SCROLL SCREEN from right Towards LEFT;=====================================================================leftscrolll:	jsr	leftscroll	rtl	leftscroll:	cmp #0	beq nono		sta scroll_left	lsr a	sta halfscroll_left		lda Hpos 		;update hscroll value	clc	adc scroll_left	sta Hpos	lda lsdir			;same scroll dir as last, or did bob turn?	cmp #0	beq @samedir	lda #1	sta changeflag	;flag old blockcount too	;	lda #sfxpunch;	jsl soundeffects	@samedir:	stz lsdir		;make left the "last" direction scrolled now		lda	introflag	bne	@noway		lda	cputime	and	#1	bne	@noway		lda Hpos2  		;update scroll	clc	adc scroll_left	sta Hpos2@noway:leftscroll2:	lda halfscroll_left	beq @nh		lda halfhpos	clc	adc halfscroll_left	sta halfhpos		@nhnono:	  	rts	;=====================================================================	; RIGHTSCROLL - SCROLL SCREEN from left Towards RIGHT;=====================================================================rightscroll:	cmp #0	beq nono		sta scroll_right	lsr a	sta halfscroll_right		lda Hpos	sec	sbc scroll_right	sta Hpos	sta hposc	lda lsdir			;same scroll dir as last, or did bob turn?	cmp #1	beq @samedir	lda #1	sta changeflag	;flag old blockcount too	;	lda #sfxclimb;	jsl soundeffects@samedir:	lda #1	sta lsdir		;make left the "last" direction scrolled now		lda	cputime	and	#1	bne	@noway		lda Hpos2  		;update vscroll	sec	sbc scroll_right	sta Hpos2@noway:rightscroll2:	lda halfscroll_right	beq @nh	lda halfhpos	sec	sbc halfscroll_right	sta halfhpos	@nh	rts;=====================================================================	; UPSCROLL - SCROLL SCREEN from bottom to TOP;=====================================================================;=====================================================================	; UPSCROLL - SCROLL SCREEN from bottom to TOP;=====================================================================upscroll:	sta scroll_up	lsr a	sta halfscroll_up	lda Vpos 		;update vscroll	clc	adc scroll_up	sta Vpos	lda	maptype	cmp	#bubblelevel	bne	upscroll2	lda	cputime	and	#1	bne	upscroll2		lda Vpos2  		;update vscroll	clc	adc scroll_up	sta Vpos2	upscroll2:	lda halfscroll_up	beq @nh	lda halfvpos	clc	adc halfscroll_up	sta halfvpos	@nh  	rts;=====================================================================	; DOWNSCROLL - SCROLL SCREEN FROM top to BOTTOM;=====================================================================downscroll	proc	sta scroll_down	lsr a	sta halfscroll_down		lda Vpos	sec	sbc scroll_down	sta Vpos		lda	maptype	cmp	#bubblelevel	beq	@movepara	lda	status	cmp	#rideship	bne	downscroll2	@movepara:	lda	cputime	and	#1	bne	downscroll2		lda Vpos2  		;update vscroll	sec	sbc scroll_down	sta Vpos2downscroll2:	lda halfscroll_down	beq @nh	lda halfvpos	sec	sbc halfscroll_down	sta halfvpos	@nh    rts	;-------------------------------------------------------------------------*	*	set screen address for current row of vscroll data*setaddrv	proc	stz vaddr	stz	vaddr+1		stz temp+1	clc	lda Vpos			;set lo screen addr	clc	adc topoffset	and #%11111000			;mask off low vscroll bits	clc	asl a	rol temp+1	asl a 	rol temp+1	asl a 	rol temp+1				;multiply by 64 to get proper row	clc	adc put	sta vaddr	bcc @skip16bit		inc temp+1	@skip16bit:	lda temp+1	clc	adc put+1	sta vaddr+1	**	update vertical block pointers*	lda scroll_down	bne topblock	lda scroll_up	bne @bottomblock	rts@bottomblock:;inc block pointers while scrolling up	lda scroll_up	clc	adc blockcountv	cmp #32			;6 chars high * 8 picels/char	bcc sameblock		;not over block's scroll limit	and #%00011111		;wrap around value at 32 pixels (4 chars)	sta blockcountv	lda mapwidth		;down one row	jsr map_add	inc mapcountv	inc	edmapcountv	rtssameblock:	sta blockcountv; 	jsl generate_bottom_enemies	rts	topblock:	lda blockcountv	sec	sbc scroll_down	bcs sameblockv2			;not over scroll limit		and #%00011111			;wrap around value at 32 pixels (4 chars)	sta blockcountv	lda mapwidth			;up one row	jsr map_sub	dec mapcountv	dec edmapcountv	rts	sameblockv2:	sta blockcountv;	jsl generate_top_enemies	rts		**		set screen address for horizontal column scroll*setaddrh:				;set horizontal scroll addr for char data	;get v offset first		stz temp+1	lda Hposc			;set lo screen addr (the current column);	sec;	sbc #8	and #%11111000	lsr a	lsr a					;shift away low hscroll bits	clc	adc put	sta haddr	bcc @skip16bit		inc temp+1	@skip16bit:	lda temp+1	clc	adc put+1	sta haddr+1			;-----------------------------------------			;update block pointers		;-----------------------------------------	lda scroll_right	bne goingright	lda scroll_left	bne goingleft	rtsgoingleft:		;inc block pointers while scrolling right to left	lda blockcounth	clc	adc scroll_left 	cmp #32				;4 chars wide * 8 pixels/char	bcc sameblockh		;not over block's scroll limit	and #%00011111		;wrap value at 32	sta blockcounth	lda #1			;add 1 column	jsr map_add	inc mapcounth	rtssameblockh:	and #%00011111		;wrap value at 32	sta blockcounth; 	jsl generate_right_enemies	rts	goingright:	lda blockcounth	sec	sbc scroll_right	bcs sameblockh2			;not over scroll limit		and #%00011111			;cause wraparound value	sta blockcounth	lda #1				;less 1 column	jsr map_sub	dec mapcounth	rts	sameblockh2:	and #%00011111		;wrap value at 32	sta blockcounth	;  	jsl generate_left_enemies	rts	;-----------------------------------------------------------------------fillbufferv:		;fill vertical scroll buffer		lda map	sta temp	lda map+1	sta temp+1			;temp now holds current map addr	lda blockcountv	sta tempblockcountv		;save off current blockcountv	ldy topoffset	beq @same_maploc2			;bne		sec	sbc #8			sta blockcountv	bcs @same_maploc2		lda blockcountv	and #31	sta blockcountv		lda temp			;block wrapped so inc temp map pointer 1	sec	sbc mapwidth	sta temp	bcs @same_maploc2	dec temp+1	@same_maploc2:;determine where to get & put map data	lda scroll_up	bne @fb0			;must be scrolling up	lda scroll_down			;if not down then look at lastdir	bne @fb1	lda topoffset	beq @fb1	@samedir:@fb0:	lda mapwidth	jsr temp_add2	lda mapwidth	jsr temp_add2	lda mapwidth	jsr temp_add2	lda mapwidth	jsr temp_add2	lda mapwidth	jsr temp_add2	lda mapwidth	jsr temp_add2	lda mapwidth	jsr temp_add2	lda mapwidth	jsr temp_add2		@fb1:		;now have correct map addr. Get blocks and drop in buffer.		;--------------------------------------------------------dropblockv1:	lda blockcounth		;fudge to left 1 char;	sec;	sbc #8				sta blockcounthtemp;	bcs @same_maploc	;	lda blockcounthtemp;	and #31;	sta blockcounthtemp;	lda temp			;block wrapped so dec temp map pointer ;	sec;	sbc #1;	sta temp;	bcs @same_maploc;	dec temp+1	@same_maploc:		lda #0	sta buffercount		;reset buffer length counter				;-----------------------------	ldy #0	jsr getblockaddr		;get current block addr	lda blockcounthtemp	lsr a	lsr a				;get xoffset within block 1	and #%11111110	jsr dropblockv			;put this block in buffer	ldy #1	jsr getblockaddr		;get current block addr	jsr dropblockv2			;put this block in buffer	ldy #2	jsr getblockaddr		;get current block addr	jsr dropblockv2			;put this block in buffer	ldy #3	jsr getblockaddr		;get current block addr	jsr dropblockv2			;put this block in buffer	ldy #4	jsr getblockaddr		;get current block addr	jsr dropblockv2			;put this block in buffer	ldy #5	jsr getblockaddr		;get current block addr	jsr dropblockv2			;put this block in buffer	ldy #6	jsr getblockaddr		;get current block addr	jsr dropblockv2			;put this block in buffer	ldy #7	jsr getblockaddr		;get current block addr	jsr dropblockv2			;put this block in buffer	ldy #8	jsr getblockaddr		;get current block addr	jsr dropblockv2			;put this block in buffer@endfillv:		;now adjust buffer for hscroll	lda #64	sta temp		stz temp+1;	lda scroll_left;	bne @doset	;	lda scroll_right;	bne @setset			;keep same map offset (upper left)@	;	lda sideoffset			;current correct version;	bne @setset@doset:	lda #66			;was 33 in NES	sta temp	lda #2			;was 1 in NES	sta temp+1@setset:			lda Hpos		;hscroll offset	and #%11111000	lsr a	lsr a 	sta tmp		lda #64		  	sec	sbc tmp				tay	cpy #64	bne @ready		ldy #0@ready:	ldx #0@m1:	lda buffer,y	sta vbuffer,x	inx	cpx #64	beq @m2	iny	cpy temp	bcc @m1			ldy temp+1	  	bra @m1@m2:		;done!	lda tempblockcountv	    	;done.	sta blockcountv	rts;-----------------------------------------------------------------------fillbufferh:		;fill horiz. scroll buffer		lda map_current	sta temp	lda map_current+1	sta temp+1			;temp now holds current map addr	lda blockcounthc		;if drawing to left side update blocks	pha	;	sec;	sbc #8			;sideoffset;	sta blockcounthc;	bcs @same_maploc	;	lda blockcounthc;	and #31;	sta blockcounthc;	lda temp			;block wrapped so inc temp map pointer 1;	sec;	sbc #1;	sta temp;	bcs @same_maploc;	dec temp+1	@same_maploc:	lda lsdir		;if no dir then base on last dir	bne @fb1@fb0:		lda temp	clc	adc #8				;add offset to get right blocks						;from map data	sta temp 			;set low		bcc @a1	inc temp+1			;set high@a1:@fb1:	@final_side:		;now have correct map addr. Get blocks and drop in buffer.		;--------------------------------------------------------	lda #0	sta buffercount		;reset buffer length counter			;first block is a special case - sets offset for			;other blocks to follow...	ldy #0					;y holds offset within map	jsr getblockaddr		;get leftmost block addr	lda blockcountvc	      	;get vertical row within block	and #%11111000	sta tmp	lda blockcounthc	lsr a	lsr a	and #%11111110	clc	adc tmp	jsr drophblocksub2	jsr drophblocksub		;drop 4 remaining blocks vertically	jsr drophblocksub	jsr drophblocksub	jsr drophblocksub	jsr drophblocksub	jsr drophblocksub	jsr drophblocksub	jsr drophblocksub	@endfillh:**		now shift the data in the buffer to match with the screen's v offset*			lda Vposc			;figure out where first visible row is onscreen 	lsr a	lsr a	and #%11111110		;mask off low bit for word's sake	tax					;x holds row number (in word offset) 0...31		ldy #0				;y is counter for buffer	@hshift:	lda hbuffer,y	;copy low byte	sta hbuffer2,x	iny	inx	lda hbuffer,y		;copy high byte	ora	bossbehind	;#%00100000		;priority  in front of	sta hbuffer2,x	iny	inx	cpy #63				;is buffer full yet?	bcs @done_hshift		cpx #64				;is buffer wrapping at this point?	bcc @hshift		ldx #0				;reset hbuffer pointer to get rest of data in proper order	bra @hshift	@done_hshift:; now copy buffer back into hbuffer to finish process;	ldx #0;@copy_again:;	lda buffer,x;	sta hbuffer,x;	inx;	cpx #64;	bcc @copy_again				pla	sta blockcounthc			rts;----------------------------------------------------------------------drophblocksub	proc	ldy #0	jsr getblockaddr		;get current block addr	lda blockcounthc		;get xoffset within block	lsr a	lsr a	and #%11111110drophblocksub2:	jsr dropblockh			;put this block in buffer	lda temp	clc	adc mapwidth	sta temp			;move map pointer down one row	bcc @a2	inc temp+1@a2:	rts	;--------------------------------------------------------------------------dropblockh	proc	tay			;y now holds offset within block data	ldx buffercount	;get current buffer count	lda blockpage	;#3			;blocks are in bank 3 for now...	pha	plb	@droplooph:	lda (blockaddr),y	sta hbuffer,x		;put low byte of char data in hscroll buffer		iny					;increase pointers for high byte of data	inx		lda (blockaddr),y		;put high byte of data in hscroll buffer		sta hbuffer,x			inx	iny		inc buffercount     	;increase counters again	inc buffercount		tya	clc	adc #6 		;add 7 to go down one row within block to next low byte	tay				cpy #31  		;at max block height?	bcc @droplooph		;if no then keep filling buffer	lda #0	pha	plb 		rts				;done with this block;--------------------------------------------------------------------------dropblockv2	proc	lda #0dropblockv:	sta tmp		     	;holds first x offset within block	lda blockcountv	      	;get vertical row within block	and #%11111000	clc	adc tmp			;add xoffset	tay			;y now holds offset within block data	ldx buffercount	;get current buffer count	lda blockpage	;#3	pha	plb		;bank 3	@droploopv:		lda (blockaddr),y	sta buffer,x		;put low byte char in vbuffer	inx	iny		lda (blockaddr),y	ora	bossbehind	;#%00100000		;prior-in front of....	sta buffer,x		;put high byte char in vbuffer	inc buffercount	inc buffercount     	;increase counters	iny	inx		      	inc tmp	inc tmp		lda tmp	cmp #8				;at max block width@	bcc @droploopv	lda #0	pha	plb 		rts;----------------------------------------------------------------map_add:	 ;universal mappointer add routine	sta tempadd	lda map	clc	adc tempadd	sta map	bcc @m1	inc map+1@m1	rts;---------------------------------------------------------------------map_sub:	 ;universal mappointer subtract routine	sta tempadd	lda map	sec	sbc tempadd	sta map	bcs @m1	dec map+1@m1	rts;---------------------------------------------------------------------	**  additonal routines for scrolling*;---------------------------------------------------------------------tmp_add:	 ;universal mappointer add routine	sta tempadd	lda tmp	clc	adc tempadd	sta tmp	bcc @m1	inc tmp+1@m1:	rts;---------------------------------------------------------------------tmp_sub:	 ;universal mappointer subtract routine	sta tempadd	lda tmp	sec	sbc tempadd	sta tmp	bcs @zm1        dec tmp+1@zm1:	rts	;-----------------------------------------------------------------------getblockaddr:			;get block data addr, based on "temp" map pointer			phb		;Y holds x-offset of block 	lda #$7e	pha	plb				;set bank $7e data register		lda (temp),y		;get map data	sta whichblock		plb	stz blockaddr+1		lda whichblock	sta tmp			;holds block offset value	sta WRMPYA			;multiplicand	lda #32	sta WRMPYB			;multiplier		;block number * 32 chars		nop	nop	nop	nop	nop	nop	nop	nop		lda RDMPYL	sta tmp+2	lda RDMPYH	sta tmp+3	** and add start of block page*	lda tmp+2			;get results	clc	adc blockaddress		sta blockaddr		bcc @higher2a		inc blockaddr+1	@higher2a:	lda tmp+3	clc	adc blockaddress+1		clc	adc blockaddr+1	sta blockaddr+1	rts 		rts 	;----------------------------------------------------------------------**	DUMPBUFFERS - dump H & V buffers into screen ram area*dumpbufferh:			;dump hscroll buffer	bra @leavealone		lda screenfake	beq @leavealone		lda TSKclock	and #15	bne @leavealone		ldy #0	lda #1@loopy:	sta hbuffer2,y	iny	cpy #64	bcc @loopy	@leavealone:	SET16		lda haddr		;dump buffer to side of screen	sta tmp		ldy #0	tyx	@dumph:	lda hbuffer2,y		;get word and dump in the buffer	sta (tmp)		lda tmp				;move down one character onscreen	clc	adc #64	sta tmp		iny	iny	inx	cpx #32				;number of rows to dump vertically	bcc @dumph		SET8		rts	;----------------------------------------------------------------	dumpbufferv:	;	now do vertical buffer to top of screen	SET16	lda vaddr		;dump buffer to side of screen	sta tmp		ldy #0	tyx	@dumpv:	lda vbuffer,y	sta (tmp)		lda tmp	clc	adc #2	sta tmp		iny	iny	inx	cpx #32	bcc @dumpv		SET8		rts				;---------------------------------------------------------------------	**	pull map out of rom and decompress into ram scroll map & task map*makemap:	stx tmp+4			;source rom bank of map to be decompressed		sta tmp+2	sty tmp+3			;source address within bank of current map			lda #<scrollmap			;dest address of current map data (rom or ram)		sta temp		lda #>scrollmap			sta temp+1				lda #<taskmap			;dest address of current map data (rom or ram)		sta temp+2		lda #>taskmap			sta temp+3		        lda #<$0000        sta WMADDL              ;set to read from bank $7f WRAM        lda #>$0000        sta WMADDM        lda #1        sta WMADDH		ldy #0@copy_map:			;	lda tmp+4	;	pha	;	plb		;	lda (tmp+2),y		;get rom map data source			lda	WMDATA			cmp #$ff		bne @not_trigger		;is this a task trigger?		@trigger:					;trigger a task here	;	iny	;	lda (tmp+2),y		;get normal block		lda	WMDATA		pha			;	iny	;	lda (tmp+2),y		;get task trigger number			lda	WMDATA		pha				lda #$7e			;set ram bank $7e		pha		plb				ldy #0		pla					;get block		sta (temp+2),y		;save task number into task map		pla		sta (temp),y		;save block into scroll map				lda	#0		pha		plb				;	lda tmp+2			;inc data pointer	;	clc	;	adc #3	;	sta tmp+2	;	bcc @next_block	;	inc tmp+3@trig1:		bra @next_block		@not_trigger:		pha					;save block				lda #$7e			;set ram bank $7e		pha		plb				pla					;get block		sta (temp),y		;save block into scroll map				lda #0		sta (temp+2),y		;zero out task map				lda	#0		pha		plb			;	lda tmp+2			;inc data pointer	;	clc	;	adc #1	;;	sta tmp+2	;	bcc @next_block	;		;	inc tmp+3		@next_block:		lda temp			;inc scroll map dest pointer		clc		adc #1		sta temp		bcc @next1				inc temp+1		@next1:		lda temp+2			;inc task map dest pointer		clc		adc #1		sta temp+2		bcc @next2				inc temp+3		@next2:		lda temp+1			;filled map yet?		cmp #>scrollmap+mapsize		bcc @copy_map			;keep looping						;now clear area above task map to avoid bad generate values				SET16				ldx #0		txa		@cleartask:		sta taskmap-bufferarea,x		;blank out task zone above map		inx		cpx #bufferarea		bne @cleartask				SET8						lda #$0			;reset data pointer		pha		plb		ldx TSKcurrent				rts		temp_add2	proc			;universal temp add	sta tempadd		lda temp	clc	adc tempadd	sta temp	bcc @ta1		inc temp+1	@ta1:	rts** initialize music system*initmusic:	LDA	#<ROMADRS	; sound data address set	STA	ADDRESS	LDA	#>ROMADRS	STA	ADDRESS+1	LDA	#ROMADRS>>16			;assume BANK 0 for ROMADRS	STA	ADDRESS+2	bra	mybootapuinitsound:	LDA	#<ROMADRS2	; sound data address set	STA	ADDRESS	LDA	#>ROMADRS2	STA	ADDRESS+1	LDA	#ROMADRS2>>16			;assume BANK 0 for ROMADRS	STA	ADDRESS+2	bra	mybootapuinitsound2:	LDA	#<ROMADRS3	; sound data address set	STA	ADDRESS	LDA	#>ROMADRS3	STA	ADDRESS+1	LDA	#ROMADRS3>>16				STA	ADDRESS+2	bra	mybootapuinitsound3:	LDA	#<ROMADRS4		STA	ADDRESS	LDA	#>ROMADRS4	STA	ADDRESS+1	LDA	#ROMADRS4>>16				STA	ADDRESS+2mybootapu:		JSR	BOOT_APU	; boot APU [sound program transfer ]	lda	#0	sta	frame	sta	inputcount	sta	outputcount	LDA	#$00		; port clear	STA	APU_PORT0	; sound clear	rts		;**************************************;*      SOUND BOOT LOADER  V1.1       *;**************************************BOOT_APU	lda	#$e5	sta  APU_port0	PHP	REP	#%00110000	LDY	#0	LDA	#$BBAABOOT_INITIAL	CMP	APU_PORT0	;M16	BNE	BOOT_INITIAL	SEP	#%00100000;	LDA 	#$CC	BRA	BOOT_ENTRY1BOOT_REPEAT	LDA	[ADDRESS],Y	INY	BPL	BANKIT1	LDY	#0	INC	ADDRESS+2BANKIT1	XBA	LDA	#0	BRA	BOOT_ENTRY2BOOT_LOOP	XBA	LDA	[ADDRESS],Y	INY	BPL	BANKIT2	LDY	#0	INC	ADDRESS+2BANKIT2	XBABOOT_WAIT1	CMP	APU_PORT0	BNE	BOOT_WAIT1	INC	ABOOT_ENTRY2	REP	#%00100000	STA	APU_PORT0	;M16	SEP	#%00100000		DEX	BNE	BOOT_LOOPBOOT_WAIT2	CMP	APU_PORT0	BNE	BOOT_WAIT2BOOT_ZERO	ADC	#3	BEQ	BOOT_ZEROBOOT_ENTRY1	PHA			;>	REP	#%00100000	LDA	[ADDRESS],Y	;M16	INY	INY	TAX	LDA	[ADDRESS],Y	;M16	INY	INY	STA	APU_PORT2	;M16	SEP	#%00100000	CPX	#1	LDA	#0	ROL	A	STA	APU_PORT1	ADC	#$7F	PLA			;<	STA	APU_PORT0BOOT_WAIT3	CMP	APU_PORT0	BNE	BOOT_WAIT3	BVS	BOOT_REPEAT	PLP		SET8		;return in 8 bit mode	RTS	** sfx call*SoundEffects2	;SoundEffects2 called with A in 8 bit mode . A  from sound buffer	php	sep	#$20	sta  APU_port0	inc	ADDRESS	lda	ADDRESS	sta	APU_port1	plp	SET8	rtl	** sfx call by game code*;SoundEffects called with A in 8 bit mode . A = effect number....soundeffects	phy	phx	php	sep	#$30	tay	lda	inputcount	inc	a	inc	a		sta	inputcount	and	#$0f	tax	tya	sta	soundbuffer,x			;silence for now	plp	plx	ply	SET8	ldx	TSKcurrent	rtl** vbl refresh routine*refreshsoundeffect	php	sep	#$30	lda	frame	and	#1	bne	@1	lda	outputcount	cmp	inputcount	beq	@1	inc	a		inc	a	sta	outputcount	and	#$0f	tax	lda	soundbuffer,x	jsl	soundeffects2@1	plp	SET8	ldx	TSKcurrent	rtl		