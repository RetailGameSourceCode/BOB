**	UNIVERSAL ROUTINE TO DETERMINE BLOCK AND BG CHAR VALUES UNDER A*	TASK.*bgcoll_long:	phb;	pha;	lda	#0;	pha;	plb;	pla	jsr bgcoll	plb	rtl	findwall_long:	jsr	findwall	rtl	findfloor_long:	jsr	findfloor	rtl	* ACC HOLDS XOFFSET (+- 128) AND A Y OFFSET (+-128) FROM TASK X,Ycollide:	sta temp+2		;xoffset	sty temp+3		;yoffset	phb;	jsl	PICyflip		lda PICxlo,x	pha	lda PICylo,x	pha	lda PICxhi,x	pha	lda PICyhi,x	pha						;save off x,y to restore later	lda blockcounth	jsl PICxadd	lda temp+2	jsl PICxadd	lda PICxlo,x			;get h screen offset in blocks	lsr a	lsr a	lsr a	lsr a	lsr a	sta temp+4				;block x offset     lda temp+3	jsl PICyadd	;;	lda	PICylo,x;;	sta face		lda blockcountv	jsl PICyadd		lda PICylo,x		;find row offset - mult. y/32 * mapwidth	lsr a	lsr a	lsr a	lsr a	lsr a		;/32	sta WRMPYA			;multiplicand	lda mapwidth	sta WRMPYB			;multiplier		lda RDMPYL			;get results	sta tmp	lda RDMPYH	sta tmp+1		lda map+1	clc	adc tmp+1		;add high byte of multiply result	sta temp+1	lda map	clc	adc tmp		;add low of multiply result	bcc @overflow		inc temp+1		;inc high again	@overflow:	sta temp		;check for offscreen collisions	lda PICxhi,x	beq @checkyhi		;not off for x		bmi @leftoff	@rightoff:	lda temp	clc	adc #8	sta temp	bcc @rightoffadd	inc temp+1@rightoffadd:	bra @checkyhi@leftoff:	lda temp	sec	sbc #8	sta temp	bcs @leftoffadd	dec temp+1@leftoffadd:@checkyhi:		;look for offscreen y values	lda PICyhi,x	beq @onscreen 		;not off for x	bmi @topoff@bottomoff:			;off bottom of screen	lda #8	sta WRMPYA			;multiplicand	lda mapwidth	sta WRMPYB			;multiplier		lda temp+1	clc	adc RDMPYH		;add high byte of multiply result	sta temp+1	lda temp	clc	adc RDMPYL		;add low of multiply result	sta temp	bcc @bo1		inc temp+1	@bo1:	bra @onscreen@topoff:	 		;off top of screen	lda #8	sta WRMPYA			;multiplicand	lda mapwidth	sta WRMPYB			;multiplier		lda temp+1	sec	sbc RDMPYH		;add high byte of multiply result	sta temp+1	lda temp	sec	sbc RDMPYL		;add low of multiply result	sta temp	bcs @bo2		dec temp+1	@bo2:	@onscreen:		lda temp	clc	adc temp+4			;xoffset	sta temp	bcc @a2	inc temp+1@a2:;must restore original PIC positions now	pla	sta PICyhi,x	pla	sta PICxhi,x	pla	sta PICylo,x	pla	sta PICxlo,x		;now calculate location WITHIN block	lda PICxlo,x	clc	adc blockcounth	clc	adc temp+2	lsr a	lsr a	and #%00000110	sta temp+4			;holds char. xoffset within block		lda PICylo,x	clc	adc temp+3	clc	adc blockcountv	and #%00011000	clc	adc temp+4	sta temp+4			;now holds char offset within block 	ldy #0	jsr getblockaddr	;find block contents address	ldx TSKcurrent		lda blockpage	pha	plb		ldy temp+4	lda (blockaddr),y	sta whichchar					;tmp now holds the collision character	iny	lda (blockaddr),y	and #%1	sta whichchar+1		jsr	charactertype		plb	rts** ACC=X offset (+-128) Y=Y offset (+-128)*bgcoll:		sta collxoff	sty collyoff				*	first test for offscreen points		lda collxoff	bpl	@xp		; Is X offset positive@@xn:	eor	#255	clc	adc	#1		; Otherwise negate it!	sta	tmpx	lda	PICxlo,x	; Where we are	sec	sbc	tmpx	sta tmpx	bcs @xok	jmp @exit	@xp:	lda PICxlo,x	clc	adc collxoff	sta tmpx	bcc @xok		jmp @exit	@xok:	lda collyoff	bpl	@yp		; Is Y offset positive@@yn:	eor	#255	clc	adc	#1		; Otherwise negate it!	sta	tmpy	lda	PICylo,x	; Where we are	sec	sbc	tmpy	sta tmpy	bcs @yok	jmp @exit	@yp:	lda PICylo,x	clc	adc collyoff	sta tmpy	bcc @yok	@gotoexit:	jmp @exit	@yok:	lda tmpx	cmp #16	bcc @gotoexit	cmp #256-16	bcs @gotoexit		lda tmpy	cmp #16	bcc @gotoexit	cmp #256-16	bcs @gotoexit* now do normal stuff...@normal:;	jsl	PICyunflip		lda collxoff;	sec;	sbc	#8			;system fudge	pha	lda	mapcounth	and	#7	asl	a	asl	a	asl	a	asl	a	asl	a	clc	adc	blockcounth	sta	tmp             ; tmp=put buffer offset	pla	ora	#0	bpl	@xop		; Is X offset positive@	eor	#255	clc	adc	#1		; Otherwise negate it!	sta	tmpx	lda	PICxlo,x	; Where we are	sec	sbc	tmpx		pha	lda	PICxhi,x	sbc	#0	beq	@onscreenh	pla	lda	#0	rts	@onscreenh:	pla	clc	adc	tmp		; Add put buffer offset			pha	and	#7	sta	imbedx	pla	lsr	a	lsr	a		; Convert to word offset	and	#$fe	sta	tmpx	bra	@xon@xop:	clc	adc	PICxlo,x	pha	lda	PICxhi,x	adc	#0	beq	@onscreen1	pla	lda	#0	rts@onscreen1:	pla	clc	adc	tmp		pha	and	#7	sta	imbedx	pla		lsr	a	lsr	a		; Convert to word offset	and	#$fe	sta	tmpx@xon:	lda	mapcountv	and	#7	asl	a	asl	a	asl	a	asl	a	asl	a	clc	adc	blockcountv	sta	tmp	tya			; Get Y offset into accumulator	ora	#0	bpl	@yop		; Is X offset positive@	eor	#255	clc	adc	#1		; Otherwise negate it!	sta	tmpy	lda	PICylo,x	; Where we are	sec	sbc	tmpy	pha	lda	PICyhi,x	sbc	#0	bne	@offscreen	pla	clc	adc	tmp		pha	and	#7	sta	imbedy	pla		SET16	and	#$f8		; Mask off lower 3 bits	asl	a	asl	a	asl	a	clc	adc	#$1300	sta	tmpy		; Convert to vertical offset	bra	@yon	SET8@yop:	clc	adc	PICylo,x	pha	lda	PICyhi,x	adc	#0	bne	@offscreen	pla	clc	adc	tmp		pha	and	#7	sta	imbedy	pla		SET16	and	#$f8		; Mask off lower 3 bits	asl	a	asl	a	asl	a	clc	adc	#$1300		; We're looking into the put screen.	sta	tmpy		; Convert to vertical offset@yon:	SET8		ldy	tmpx	lda	(tmpy),y	sta whichchar					;tmp now holds the collision character	iny	lda (tmpy),y	and #%1	sta whichchar+1	jsr	charactertype	rts	@offscreen:	pla	lda	#0	rts	@exit:	lda collxoff	ldy collyoff	jmp collide	** scan the map*xm	lda	tmpx	sec	sbc	#2	and	#63	sta	tmpx	tay	lda	(tmpy),y	sta whichchar					;tmp now holds the collision character	iny	lda (tmpy),y	and #%1	sta whichchar+1	jsr	charactertype	rts	xp:	lda	tmpx	clc	adc	#2	and	#63	sta	tmpx	tay	lda	(tmpy),y	sta whichchar					;tmp now holds the collision character	iny	lda (tmpy),y	and #%1	sta whichchar+1	jsr	charactertype	rts	ym:	SET16	lda	tmpy	sec	sbc	#64	cmp	#$1300	bcs	@nowrap	clc	adc	#2048@nowrap:	sta	tmpy	SET8	ldy	tmpx	lda	(tmpy),y	sta whichchar					;tmp now holds the collision character	iny	lda (tmpy),y	and #%1	sta whichchar+1	jsr	charactertype	rts	yp:	SET16	lda	tmpy	clc	adc	#64	cmp	#2048+$1300	bcc	@nowrap	sec	sbc	#2048@nowrap:	sta	tmpy	SET8	ldy	tmpx	lda	(tmpy),y	sta whichchar					;tmp now holds the collision character	iny	lda (tmpy),y	and #%1	sta whichchar+1	jsr	charactertype	rts		